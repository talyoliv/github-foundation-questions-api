[
  {
    "id": 1,
    "text": "Uma equipe de desenvolvimento está crescendo rapidamente e a colaboração no código se tornou caótica, com versões conflitantes e perda de trabalho. Qual é a principal solução que o controle de versão, como o Git, oferece para este cenário, e por que ela é mais eficaz do que simplesmente compartilhar arquivos em uma pasta na nuvem?",
    "options": [
      { "id": "a", "text": "Otimizar o desempenho do código em produção através de compilação automática." },
      { "id": "b", "text": "Automatizar a geração de documentação técnica do projeto com base nos comentários do código." },
      { "id": "c", "text": "Fornecer um sistema para rastrear alterações no código, permitir que múltiplos desenvolvedores trabalhem em paralelo sem sobrescrever o trabalho uns dos outros, reverter para estados anteriores e gerenciar diferentes linhas de desenvolvimento (branches). Diferentemente de pastas na nuvem, Git oferece histórico detalhado, merges inteligentes e resolução de conflitos." },
      { "id": "d", "text": "Gerenciar apenas projetos que utilizam uma única linguagem de programação, simplificando a estrutura." }
    ],
    "correctAnswerId": "c",
    "explanation": "Controle de versão (como o Git) é fundamental para registrar alterações, facilitar a colaboração, permitir a recuperação de versões e gerenciar branches, especialmente em equipes. Ele resolve problemas de concorrência e rastreabilidade de forma muito mais robusta que o simples compartilhamento de arquivos."
  },
  {
    "id": 2,
    "text": "Um desenvolvedor precisa implementar uma funcionalidade experimental que pode quebrar a aplicação. Ele quer isolar esse trabalho do branch principal (`main`) e, ao mesmo tempo, permitir que um colega revise o código antes de qualquer integração. Como Git e GitHub colaboram para atender a essa necessidade de forma segura e colaborativa?",
    "options": [
      { "id": "a", "text": "Git permite a criação de um 'branch' local, que é uma linha de desenvolvimento independente. O desenvolvedor pode commitar suas alterações experimentais nesse branch. GitHub, como plataforma de hospedagem, permite que esse branch seja enviado (push) para o repositório remoto, onde um 'Pull Request' pode ser aberto para discussão, revisão de código pelo colega e execução de testes automatizados antes de mesclar no `main`." },
      { "id": "b", "text": "O GitHub automaticamente cria backups diários do branch `main`, e o Git permite reverter commits individualmente, o que é suficiente para experimentação." },
      { "id": "c", "text": "Git apenas armazena metadados sobre os arquivos, enquanto o GitHub armazena o código real e gerencia os branches diretamente na nuvem." },
      { "id": "d", "text": "Apenas o GitHub permite a criação de branches; o Git é usado para enviar esses branches para a nuvem e o colega deve clonar o branch para revisar." }
    ],
    "correctAnswerId": "a",
    "explanation": "Git permite branching local para desenvolvimento isolado. GitHub facilita a colaboração, o backup remoto desses branches e a integração controlada via Pull Requests, que são cruciais para revisão de código e testes antes do merge."
  },
  {
    "id": 3,
    "text": "Após realizar várias modificações em arquivos de um projeto, um desenvolvedor executa o comando `git commit -m \"Adiciona autenticação de usuários\"`. Qual é o significado e o impacto fundamental deste comando no contexto do Git, e o que acontece se ele esquecer de adicionar os arquivos à 'staging area' antes?",
    "options": [
      { "id": "a", "text": "O comando envia as alterações diretamente para o repositório remoto no GitHub, atualizando o branch `main`. Se arquivos não foram adicionados, o commit falha." },
      { "id": "b", "text": "O comando cria um novo branch chamado \"Adiciona autenticação de usuários\" e move as alterações para ele. Se não houver arquivos na staging area, o branch é criado vazio." },
      { "id": "c", "text": "O comando prepara os arquivos modificados para serem incluídos no próximo commit (staging), mas não os registra permanentemente. Se a staging area estiver vazia, o commit não terá efeito." },
      { "id": "d", "text": "O comando registra um 'snapshot' das alterações que estavam na 'staging area' no histórico local do repositório. Se a staging area estiver vazia, o commit será criado, mas não conterá nenhuma alteração de arquivo, efetivamente sendo um commit vazio (a menos que `-allow-empty` seja usado)." }
    ],
    "correctAnswerId": "d",
    "explanation": "Um 'commit' no Git salva o estado atual dos arquivos da staging area no histórico local. Se a staging area estiver vazia, `git commit` por padrão não criará um commit a menos que alterações de arquivos rastreados tenham sido preparadas ou a opção `--allow-empty` seja usada. A mensagem é essencial para descrever o snapshot."
  },
  {
    "id": 4,
    "text": "O GitHub Flow é um fluxo de trabalho leve e baseado em branches. Qual das seguintes práticas é fundamental para o GitHub Flow, e como ela se diferencia da gestão de releases no GitFlow?",
    "options": [
      { "id": "a", "text": "Manter branches de `develop` e `release` de longa duração, além do `main`, sendo `develop` o branch para integração contínua." },
      { "id": "b", "text": "Criar um branch a partir do `main`, fazer commits, abrir um Pull Request, discutir, revisar, testar e, uma vez aprovado e com os testes passando, fazer o merge no `main` e deploy imediatamente. O branch de funcionalidade é então deletado. GitFlow usa branches `release` para preparar lançamentos, o que não é uma prática do GitHub Flow." },
      { "id": "c", "text": "Fazer deploy diretamente de branches de funcionalidade para produção antes de mesclar no `main`, para testes A/B." },
      { "id": "d", "text": "Evitar o uso de Pull Requests para acelerar o desenvolvimento, confiando em merges diretos no `main`." }
    ],
    "correctAnswerId": "b",
    "explanation": "O GitHub Flow enfatiza branches de funcionalidade de curta duração que são mesclados diretamente no `main` e implantados continuamente. GitFlow, por outro lado, utiliza branches intermediários como `develop` e `release` para gerenciar o ciclo de vida de desenvolvimento e lançamento."
  },
  {
    "id": 5,
    "text": "Qual característica do Git como um Sistema de Controle de Versão Distribuído (DVCS) oferece a maior vantagem para um desenvolvedor trabalhando remotamente com conexões de internet instáveis, em comparação com um CVCS como SVN?",
    "options": [
      { "id": "a", "text": "O armazenamento de branches apenas no servidor central para economizar espaço local, forçando o trabalho online." },
      { "id": "b", "text": "A centralização de todas as decisões de merge em um único administrador, o que simplifica o processo remoto." },
      { "id": "c", "text": "A capacidade de cada desenvolvedor ter uma cópia completa do repositório localmente, incluindo todo o histórico. Isso permite que a maioria das operações (commit, branch, merge, view history) seja realizada offline. CVCSs tipicamente exigem conexão para essas operações." },
      { "id": "d", "text": "A necessidade de uma conexão constante com o servidor central para visualizar o histórico de commits e criar branches." }
    ],
    "correctAnswerId": "c",
    "explanation": "Sendo um DVCS, cada clone do Git contém o histórico completo, permitindo trabalho offline extensivo (commits, branches, merges locais). Isso contrasta com sistemas centralizados (CVCS) que exigem conexão para a maioria das operações."
  },
  {
    "id": 6,
    "text": "Um profissional de UX/UI deseja usar seu perfil GitHub para mostrar seus melhores projetos e contribuições de design, incluindo mockups e protótipos. Quais recursos do perfil GitHub são mais eficazes para este propósito, e como ele pode usar o Profile README para isso?",
    "options": [
      { "id": "a", "text": "Apenas dar 'star' em todos os repositórios em que contribuiu e preencher o campo 'bio' com um link para um portfólio externo." },
      { "id": "b", "text": "Apenas listar seus projetos na seção 'Achievements' e esperar que recrutadores cliquem em todos os repositórios." },
      { "id": "c", "text": "Escrever um longo Gist detalhando seu portfólio e linká-lo na bio, e fixar Gists no perfil." },
      { "id": "d", "text": "Criar um Profile README (repositório especial `username/username` com um `README.md`) para uma apresentação rica usando Markdown, onde pode incorporar imagens de mockups, links para protótipos e descrições de projetos. Adicionalmente, fixar (pin) os repositórios mais relevantes." }
    ],
    "correctAnswerId": "d",
    "explanation": "O Profile README permite uma página de perfil altamente personalizável usando Markdown, ideal para mostrar visualmente trabalhos de design. Fixar repositórios os destaca. Achievements são automáticos, e a bio é limitada."
  },
  {
    "id": 7,
    "text": "Em uma revisão de Pull Request no GitHub, um colega de equipe sugere uma pequena alteração em uma linha de código para melhorar a legibilidade. Qual é a forma mais eficiente e integrada para o revisor propor essa correção específica, permitindo ao autor aplicá-la com um clique, e qual o impacto disso no fluxo de revisão?",
    "options": [
      { "id": "a", "text": "Clonar o branch do PR, fazer a alteração, e fazer push, forçando a atualização e comentando a mudança." },
      { "id": "b", "text": "Usar a funcionalidade de 'Suggested Changes' (Sugestões de Alterações) diretamente na aba 'Files changed'. Isso permite editar a linha, propor a mudança em formato de patch, e o autor pode aceitar e commitar a sugestão diretamente, agilizando o processo." },
      { "id": "c", "text": "Enviar um e-mail ao autor com o trecho de código corrigido e pedir para ele aplicar manualmente." },
      { "id": "d", "text": "Deixar um comentário geral no PR descrevendo a alteração necessária e o número da linha." }
    ],
    "correctAnswerId": "b",
    "explanation": "As 'Suggested Changes' são uma ferramenta poderosa para revisões colaborativas, permitindo que pequenas correções sejam propostas e aceitas de forma muito eficiente pelo autor do PR, mantendo o histórico claro."
  },
  {
    "id": 8,
    "text": "Um projeto open source quer padronizar como novos contribuidores devem relatar bugs, incluindo informações sobre o ambiente e passos para reprodução, e como propor funcionalidades, detalhando o caso de uso. Qual arquivo é o local convencionalmente usado para essas diretrizes, e por que ele é importante?",
    "options": [
      { "id": "a", "text": "SECURITY.md, para detalhar vulnerabilidades e o processo de reporte seguro." },
      { "id": "b", "text": "LICENSE, para definir os termos de uso e contribuição." },
      { "id": "c", "text": "CONTRIBUTING.md, para explicar como contribuir, padrões de código, o processo de submissão de alterações e como formatar issues e PRs. Ele ajuda a manter a qualidade e consistência das contribuições." },
      { "id": "d", "text": "CODE_OF_CONDUCT.md, para estabelecer normas de comportamento na comunidade." }
    ],
    "correctAnswerId": "c",
    "explanation": "O arquivo CONTRIBUTING.md é o padrão para guiar contribuidores sobre como participar efetivamente do desenvolvimento do projeto, incluindo a formatação de issues e PRs, o que melhora a comunicação e a eficiência."
  },
  {
    "id": 9,
    "text": "Sua equipe frequentemente inicia novos microserviços que compartilham uma estrutura de diretórios (ex: `/src`, `/tests`), arquivos de configuração base (ex: `Dockerfile`, `.eslintrc.js`) e workflows de CI (ex: `build-and-test.yml`). Qual recurso do GitHub pode otimizar esse processo de bootstrapping e garantir consistência?",
    "options": [
      { "id": "a", "text": "Marcar um repositório existente como 'repository template' (modelo de repositório). Ao criar um novo repositório a partir do modelo, ele herda a estrutura de arquivos, pastas e opcionalmente todos os branches." },
      { "id": "b", "text": "Criar um Gist com os arquivos comuns e copiá-los manualmente, o que é propenso a erros." },
      { "id": "c", "text": "Usar a funcionalidade de 'fork' para cada novo microserviço e depois limpar o histórico do fork." },
      { "id": "d", "text": "Arquivar o repositório base após cada uso e desarquivá-lo para o próximo projeto." }
    ],
    "correctAnswerId": "a",
    "explanation": "Repository templates permitem que você defina um esqueleto para novos projetos, incluindo arquivos, estrutura de pastas e até branches, agilizando a criação de novos repositórios com uma base comum e promovendo a padronização."
  },
  {
    "id": 10,
    "text": "Um novo membro da equipe precisa começar a trabalhar em um projeto existente hospedado no GitHub. Qual comando Git ele deve usar para obter uma cópia completa do repositório em sua máquina local, e qual a diferença entre isso e apenas baixar um arquivo ZIP do projeto?",
    "options": [
      { "id": "a", "text": "`git init --bare <URL_do_repositorio>`, que cria um repositório compartilhado sem working directory." },
      { "id": "b", "text": "`git pull origin main`, que só funciona se o repositório já existir localmente e estiver configurado para rastrear o remote." },
      { "id": "c", "text": "`git remote add origin <URL_do_repositorio>`, que apenas configura um remote, mas não baixa os arquivos." },
      { "id": "d", "text": "`git clone <URL_do_repositorio>`. Isso baixa todo o repositório, incluindo o histórico completo do Git e todos os branches, permitindo controle de versão local. Baixar um ZIP fornece apenas os arquivos do estado atual, sem o histórico Git." }
    ],
    "correctAnswerId": "d",
    "explanation": "O comando `git clone` baixa todo o repositório, incluindo o histórico e todos os branches, para o ambiente local do desenvolvedor, o que é essencial para o controle de versão. Um ZIP é apenas um snapshot dos arquivos."
  },
  {
    "id": 11,
    "text": "Um gerente de projeto quer entender quais partes de um repositório são mais ativamente desenvolvidas (adições/remoções de código) e quem são os principais contribuidores no último mês, incluindo a distribuição de commits por dia da semana. Qual seção do GitHub fornece essas informações de forma visual e detalhada?",
    "options": [
      { "id": "a", "text": "A lista de 'Stars' do repositório, que indica popularidade." },
      { "id": "b", "text": "O arquivo `CODEOWNERS`, que define responsabilidades de revisão." },
      { "id": "c", "text": "A seção 'Insights' (ou 'Percepções') do repositório, especificamente os gráficos de 'Contributors', 'Code frequency' e 'Punch card'." },
      { "id": "d", "text": "A aba 'Actions', que mostra os workflows de CI/CD e seus históricos de execução." }
    ],
    "correctAnswerId": "c",
    "explanation": "A aba 'Insights' oferece diversas métricas sobre a atividade do repositório, incluindo gráficos de contribuições (quem e quanto), frequência de código (partes mais ativas) e o 'punch card' (atividade por dia/hora)."
  },
  {
    "id": 12,
    "text": "Você encontrou um repositório no GitHub com uma ferramenta muito útil que planeja usar futuramente e quer uma forma fácil de localizá-lo novamente e, opcionalmente, receber atualizações sobre novos releases. Qual ação é mais apropriada para 'salvar' o repositório, e qual ação para receber notificações de releases?",
    "options": [
      { "id": "a", "text": "Adicionar uma 'star' (estrela) ao repositório para salvá-lo. Para notificações de releases, usar a opção 'Watch' e customizar para 'Releases'." },
      { "id": "b", "text": "Criar uma issue no repositório com o título 'Lembrar' e seguir (follow) o proprietário." },
      { "id": "c", "text": "Fazer um fork do repositório para sua conta e configurar webhooks." },
      { "id": "d", "text": "Seguir (follow) o proprietário do repositório e adicionar aos 'bookmarks' do navegador." }
    ],
    "correctAnswerId": "a",
    "explanation": "Dar uma 'star' é a forma padrão no GitHub de marcar repositórios como favoritos. A funcionalidade 'Watch' permite configurar o nível de notificação, incluindo apenas para novos releases."
  },
  {
    "id": 13,
    "text": "Ao usar um software de código aberto, qual arquivo no repositório é crucial para entender como você pode legalmente usar, modificar e distribuir o software, e quais são as implicações de não respeitar essa licença?",
    "options": [
      { "id": "a", "text": "SECURITY.md, que detalha as vulnerabilidades conhecidas." },
      { "id": "b", "text": "README.md, que geralmente descreve o projeto mas não os termos legais completos." },
      { "id": "c", "text": "LICENSE (ou LICENSE.md, COPYING, etc.). Não respeitar a licença pode levar a consequências legais, como processos por violação de direitos autorais." },
      { "id": "d", "text": "CONTRIBUTING.md, que guia sobre como contribuir, mas não sobre o uso." }
    ],
    "correctAnswerId": "c",
    "explanation": "O arquivo LICENSE especifica os termos e condições sob os quais o software é disponibilizado, definindo permissões e restrições. Ignorar a licença pode ter sérias implicações legais."
  },
  {
    "id": 14,
    "text": "Uma equipe quer garantir que as alterações em módulos críticos de segurança (ex: arquivos em `src/auth/` e `src/crypto/`) sejam sempre revisadas por um grupo específico de especialistas (`@org/security-team`). Qual arquivo deve ser configurado para automatizar a solicitação de revisão desses especialistas em Pull Requests?",
    "options": [
      { "id": "a", "text": "O arquivo `SECURITY.md`, adicionando uma menção à equipe." },
      { "id": "b", "text": "Um `issue template` específico para segurança que instrui a marcar a equipe." },
      { "id": "c", "text": "O arquivo `CODEOWNERS`, definindo os caminhos dos arquivos e a equipe `@org/security-team` como proprietária. Isso adicionará automaticamente a equipe como revisora em PRs que modificam esses arquivos." },
      { "id": "d", "text": "O `profile README` do líder da equipe de segurança, linkando para os módulos." }
    ],
    "correctAnswerId": "c",
    "explanation": "O arquivo CODEOWNERS permite mapear arquivos ou diretórios a usuários ou equipes específicas que serão automaticamente adicionados como revisores em pull requests que modificam esses caminhos, garantindo a revisão por especialistas."
  },
  {
    "id": 15,
    "text": "Um desenvolvedor está trabalhando em um Pull Request que resolve a Issue #42. Como ele pode garantir que a Issue #42 seja automaticamente fechada quando o Pull Request for mesclado no branch padrão, e qual a vantagem de fazer isso?",
    "options": [
      { "id": "a", "text": "Incluir uma palavra-chave como `Closes #42`, `Fixes #42` ou `Resolves #42` na descrição do Pull Request ou em uma mensagem de commit dentro do PR. Isso automatiza o fechamento da issue, mantendo o rastreamento de trabalho atualizado." },
      { "id": "b", "text": "Apenas mencionar `#42` no título do Pull Request e fechar a issue manualmente." },
      { "id": "c", "text": "Adicionar um comentário no Pull Request dizendo 'Este PR resolve a issue 42' e esperar que um mantenedor feche a issue." },
      { "id": "d", "text": "Atribuir o Pull Request ao mesmo usuário que criou a Issue #42." }
    ],
    "correctAnswerId": "a",
    "explanation": "Usar palavras-chave como 'closes', 'fixes', ou 'resolves' seguidas do número da issue (ex: #123) em um PR ou commit message cria um vínculo que pode fechar a issue automaticamente no merge, melhorando o fluxo de trabalho."
  },
  {
    "id": 16,
    "text": "Quando é mais apropriado usar uma GitHub Discussion em vez de uma Issue para uma equipe que está debatendo a arquitetura de um novo módulo, considerando diferentes abordagens e coletando opiniões diversas?",
    "options": [
      { "id": "a", "text": "Para atribuir a tarefa de definir a arquitetura a um membro específico da equipe, usando uma Issue." },
      { "id": "b", "text": "Para relatar um bug específico encontrado na arquitetura atual, usando uma Issue." },
      { "id": "c", "text": "Para fazer perguntas abertas à comunidade, compartilhar ideias sobre a arquitetura, coletar feedback geral, realizar enquetes sobre preferências ou fazer anúncios sobre decisões. Discussions são ideais para conversas que não representam uma tarefa discreta e rastreável." },
      { "id": "d", "text": "Para propor uma nova funcionalidade com requisitos claros e um plano de implementação detalhado, usando uma Issue." }
    ],
    "correctAnswerId": "c",
    "explanation": "Issues são para rastrear trabalho (bugs, tarefas, features). Discussions são para conversas mais abertas, Q&A, anúncios e engajamento comunitário, como debates sobre arquitetura, onde múltiplas perspectivas são valiosas antes de definir uma tarefa."
  },
  {
    "id": 17,
    "text": "Um desenvolvedor iniciou um trabalho em uma funcionalidade complexa e quer compartilhar o progresso com a equipe para feedback inicial sobre a abordagem, mas o código ainda não está pronto para revisão formal, não passa em todos os testes e não deve acionar notificações para CODEOWNERS. Qual status de Pull Request é o mais adequado e por quê?",
    "options": [
      { "id": "a", "text": "Pull Request 'Approved' (Aprovado), para mostrar confiança no trabalho." },
      { "id": "b", "text": "Pull Request 'Draft' (Rascunho). Isso sinaliza que o trabalho está em andamento, permite visualização e comentários, mas não notifica revisores automaticamente nem aciona todos os checks obrigatórios até ser explicitamente marcado como 'Ready for review'." },
      { "id": "c", "text": "Pull Request 'Merged' (Mesclado), após fazer um merge local para testes." },
      { "id": "d", "text": "Pull Request 'Closed' (Fechado), para indicar que será reaberto mais tarde." }
    ],
    "correctAnswerId": "b",
    "explanation": "Draft pull requests sinalizam que o trabalho está em andamento. Eles permitem a visualização do código e comentários, mas não notificam revisores automaticamente nem acionam todos os checks obrigatórios até serem marcados como 'Ready for review', sendo ideais para feedback preliminar."
  },
  {
    "id": 18,
    "text": "Durante a revisão de um Pull Request, qual aba é fundamental para analisar as alterações de código linha por linha, permitindo adicionar comentários específicos a trechos modificados, sugerir alterações e visualizar o 'diff' de forma clara?",
    "options": [
      { "id": "a", "text": "Aba 'Checks' (Verificações), que mostra o status dos testes de CI." },
      { "id": "b", "text": "Aba 'Files changed' (Arquivos alterados). Esta aba apresenta o 'diff' completo, destacando adições, remoções e modificações, e é onde os revisores podem deixar comentários contextuais e sugestões." },
      { "id": "c", "text": "Aba 'Conversation' (Conversa), que contém a discussão geral sobre o PR." },
      { "id": "d", "text": "Aba 'Commits', que lista os commits individuais do PR." }
    ],
    "correctAnswerId": "b",
    "explanation": "A aba 'Files changed' mostra o 'diff' do pull request, destacando adições, remoções e modificações, e é onde os revisores podem deixar comentários contextuais no código e fazer sugestões de alteração."
  },
  {
    "id": 19,
    "text": "Um usuário deseja contribuir para um projeto open source no GitHub, mas não tem permissão de escrita direta no repositório original. Qual é o primeiro passo recomendado para ele poder propor suas alterações, e por que esse passo é necessário?",
    "options": [
      { "id": "a", "text": "Clonar o repositório original diretamente para sua máquina e tentar fazer push das alterações." },
      { "id": "b", "text": "Criar uma issue solicitando permissão de escrita aos mantenedores." },
      { "id": "c", "text": "Fazer um 'fork' do repositório original para sua própria conta GitHub. Isso cria uma cópia pessoal onde ele tem permissão total para fazer alterações, das quais pode então submeter um Pull Request para o repositório original." },
      { "id": "d", "text": "Enviar um e-mail para os mantenedores com as alterações em um arquivo patch." }
    ],
    "correctAnswerId": "c",
    "explanation": "Fazer um fork cria uma cópia pessoal do repositório. O contribuidor pode então fazer alterações no seu fork e submeter um pull request para o repositório original. Este é o fluxo de trabalho padrão para contribuições em projetos onde não se tem acesso direto de escrita."
  },
  {
    "id": 20,
    "text": "Qual é a principal utilidade dos GitHub Gists em comparação com repositórios completos, especialmente para compartilhar um script de configuração rápida ou um exemplo de código para depuração?",
    "options": [
      { "id": "a", "text": "Gists possuem um sistema de issues e pull requests mais robusto para colaboração." },
      { "id": "b", "text": "Apenas Gists podem ser privados e ter controle de versão." },
      { "id": "c", "text": "Gists são melhores para hospedar sites complexos com múltiplas páginas e domínios personalizados." },
      { "id": "d", "text": "Gists são ideais para compartilhar rapidamente pequenos trechos de código, notas, scripts ou arquivos únicos, sem a necessidade de criar um repositório formal. Eles também são versionados e podem ser clonados." }
    ],
    "correctAnswerId": "d",
    "explanation": "Gists (que são, na verdade, repositórios Git simplificados) são perfeitos para compartilhar snippets de código ou pequenas porções de texto de forma rápida e fácil, com controle de versão básico."
  },
  {
    "id": 21,
    "text": "Uma equipe de documentação quer hospedar o manual do usuário de seu software, escrito em HTML e CSS, diretamente de seu repositório GitHub, permitindo versionamento e fácil atualização. Qual serviço do GitHub é mais adequado para isso e qual branch é comumente usado?",
    "options": [
      { "id": "a", "text": "GitHub Gists para cada página HTML, vinculados a partir do README." },
      { "id": "b", "text": "GitHub Actions para compilar e enviar para um servidor externo, o que adiciona complexidade desnecessária para sites estáticos." },
      { "id": "c", "text": "GitHub Wiki, que é bom para documentação colaborativa, mas GitHub Pages é melhor para apresentar HTML/CSS/JS customizado." },
      { "id": "d", "text": "GitHub Pages. Pode ser configurado para servir arquivos de um branch específico (como `gh-pages` ou `main`/`docs`) ou de uma pasta `/docs` no branch `main`." }
    ],
    "correctAnswerId": "d",
    "explanation": "GitHub Pages é projetado para hospedar sites estáticos (HTML, CSS, JS) diretamente de um repositório, tornando-o ideal para documentação, blogs ou sites de projetos. Branches como `gh-pages` ou uma pasta `/docs` são opções comuns de fonte."
  },
  {
    "id": 22,
    "text": "Um projeto precisa automatizar o processo de build, teste e deploy sempre que um novo código é enviado para o branch principal ou um Pull Request é aberto. Qual produto do GitHub é projetado para essa finalidade e como ele é configurado?",
    "options": [
      { "id": "a", "text": "GitHub Issues, usando labels para disparar scripts." },
      { "id": "b", "text": "GitHub Actions. Configurado através de arquivos YAML na pasta `.github/workflows` do repositório, definindo eventos, jobs e steps." },
      { "id": "c", "text": "GitHub Projects, movendo cards para acionar deploys." },
      { "id": "d", "text": "GitHub Codespaces, usando a configuração `devcontainer.json` para definir o pipeline." }
    ],
    "correctAnswerId": "b",
    "explanation": "GitHub Actions permite criar fluxos de trabalho (workflows) automatizados para CI/CD, que são acionados por eventos no repositório, como pushes ou pull requests, e são definidos em arquivos YAML."
  },
  {
    "id": 23,
    "text": "Um desenvolvedor está tendo dificuldade em lembrar a sintaxe para uma operação complexa em uma nova linguagem de programação e também quer sugestões para completar blocos de código repetitivos. Qual ferramenta do GitHub, integrada ao editor de código, poderia ajudá-lo oferecendo sugestões de código baseadas em IA?",
    "options": [
      { "id": "a", "text": "GitHub CLI, para interagir com o GitHub pela linha de comando." },
      { "id": "b", "text": "GitHub Copilot. Ele funciona como um programador de par de IA, fornecendo sugestões de autocompletar para código, funções inteiras e até comentários, diretamente no editor." },
      { "id": "c", "text": "GitHub Advanced Security, para encontrar vulnerabilidades." },
      { "id": "d", "text": "GitHub Mobile, para revisar código em trânsito." }
    ],
    "correctAnswerId": "b",
    "explanation": "GitHub Copilot é um programador de par de IA que fornece sugestões de autocompletar para código e funções inteiras diretamente no editor, treinado em bilhões de linhas de código."
  },
  {
    "id": 24,
    "text": "Um colaborador quer começar a trabalhar em um projeto rapidamente, sem gastar tempo configurando o ambiente de desenvolvimento em sua máquina local, que possui recursos limitados. Qual solução do GitHub oferece um ambiente de desenvolvimento completo e configurável na nuvem, acessível via navegador ou VS Code?",
    "options": [
      { "id": "a", "text": "GitHub Desktop, que é uma aplicação local para gerenciar repositórios Git." },
      { "id": "b", "text": "O editor github.dev (pressionando '.' no repositório), que é leve mas não executa código." },
      { "id": "c", "text": "GitHub Codespaces. Ele fornece um ambiente de desenvolvimento completo na nuvem, incluindo um editor (VS Code), terminal, recursos de depuração e extensões pré-configuradas." },
      { "id": "d", "text": "Clonar o repositório e usar um editor local, o que requer configuração manual." }
    ],
    "correctAnswerId": "c",
    "explanation": "GitHub Codespaces fornece um ambiente de desenvolvimento completo na nuvem, incluindo um editor (VS Code), terminal e recursos de depuração, acessível via navegador ou VS Code, e configurável via `devcontainer.json`."
  },
  {
    "id": 25,
    "text": "Qual é a principal limitação do editor github.dev (acessado ao pressionar '.') em comparação com um GitHub Codespace, especialmente quando se trata de executar testes ou compilar um projeto?",
    "options": [
      { "id": "a", "text": "github.dev não permite visualizar arquivos Markdown ou fazer commits." },
      { "id": "b", "text": "github.dev requer uma conexão de internet mais rápida e estável que o Codespaces." },
      { "id": "c", "text": "github.dev não possui acesso a um terminal ou a capacidade de executar, compilar ou depurar código, pois é um editor leve focado em navegação e edição de arquivos. Codespaces fornecem um ambiente computacional completo." },
      { "id": "d", "text": "github.dev não permite a instalação de extensões do VS Code." }
    ],
    "correctAnswerId": "c",
    "explanation": "O github.dev é um editor web leve baseado no VS Code, ideal para revisões rápidas e pequenas edições. Já o Codespaces oferece um ambiente de desenvolvimento completo com poder computacional para executar e depurar código."
  },
  {
    "id": 26,
    "text": "Para padronizar o ambiente de desenvolvimento para todos os colaboradores de um projeto que utilizam GitHub Codespaces, incluindo a imagem base do contêiner, extensões do VS Code, variáveis de ambiente e ferramentas pré-instaladas, qual arquivo de configuração é essencial e onde ele geralmente reside?",
    "options": [
      { "id": "a", "text": "Um arquivo `Dockerfile` na raiz do projeto, usado apenas para construir a imagem." },
      { "id": "b", "text": "O arquivo `README.md` com instruções de configuração detalhadas." },
      { "id": "c", "text": "Um arquivo `devcontainer.json` (geralmente em `.devcontainer/`). Este arquivo especifica toda a configuração do ambiente de desenvolvimento em contêiner." },
      { "id": "d", "text": "Um script de shell chamado `setup_codespace.sh` que deve ser executado manualmente." }
    ],
    "correctAnswerId": "c",
    "explanation": "O arquivo `devcontainer.json` é a especificação padrão para definir e configurar ambientes de desenvolvimento em contêineres, usado pelo GitHub Codespaces e VS Code Remote - Containers para garantir consistência."
  },
  {
    "id": 27,
    "text": "Além de `push` e `pull_request`, qual dos seguintes é um tipo de evento que pode acionar um workflow de GitHub Actions, permitindo automação baseada em atividades da comunidade?",
    "options": [
      { "id": "a", "text": "Quando um usuário visualiza o arquivo README por mais de um minuto." },
      { "id": "b", "text": "Um agendamento (schedule) usando sintaxe cron, a criação ou comentário em uma issue (`issues`, `issue_comment`), ou um dispatch manual (`workflow_dispatch`)." },
      { "id": "c", "text": "Quando um repositório recebe uma nova 'star' ou um novo 'fork'." },
      { "id": "d", "text": "Apenas eventos de commit direto no branch `main`." }
    ],
    "correctAnswerId": "b",
    "explanation": "GitHub Actions pode ser acionado por uma ampla gama de eventos, incluindo `schedule` (para tarefas agendadas), `issues` (quando uma issue é aberta, editada, etc.), `workflow_dispatch` (manual), e muitos outros, não apenas `push` e `pull_request`."
  },
  {
    "id": 28,
    "text": "Uma organização está considerando adotar o GitHub Copilot para suas equipes de desenvolvimento. Qual é a principal vantagem do GitHub Copilot for Business em relação ao GitHub Copilot for Individuals nesse contexto, especialmente em relação à gestão de licenças e políticas de uso?",
    "options": [
      { "id": "a", "text": "Copilot for Individuals é mais caro e oferece menos recursos que o for Business." },
      { "id": "b", "text": "Apenas Copilot for Business funciona com repositórios privados e oferece sugestões de código mais precisas." },
      { "id": "c", "text": "Copilot for Business inclui gerenciamento centralizado de licenças para os membros da organização, políticas de uso (como exclusão de sugestões baseadas em código público) e pode ter opções de faturamento mais adequadas para empresas." },
      { "id": "d", "text": "Copilot for Individuals não permite o uso em ambientes IDE, apenas no editor do github.com." }
    ],
    "correctAnswerId": "c",
    "explanation": "GitHub Copilot for Business adiciona recursos de administração (gerenciamento de assentos) e gerenciamento de políticas (como a opção de bloquear sugestões que correspondam a código público) sobre a funcionalidade central do Copilot, essenciais para o uso corporativo."
  },
  {
    "id": 29,
    "text": "Uma equipe deseja visualizar e gerenciar o progresso de suas issues e pull requests em um quadro Kanban, com colunas personalizadas para 'A Fazer', 'Em Progresso', 'Em Revisão' e 'Concluído', e também automatizar o movimento de itens entre colunas. Qual recurso do GitHub é mais adequado para isso?",
    "options": [
      { "id": "a", "text": "GitHub Wiki, criando uma página com tabelas Markdown." },
      { "id": "b", "text": "GitHub Projects (a versão mais recente). Ele permite criar quadros (boards) e tabelas (tables) altamente personalizáveis, com automação de fluxos de trabalho para mover itens com base em gatilhos (ex: PR aberto move para 'Em Revisão')." },
      { "id": "c", "text": "A aba 'Insights' do repositório, que mostra dados históricos." },
      { "id": "d", "text": "GitHub Gists, usando um Gist para listar as tarefas." }
    ],
    "correctAnswerId": "b",
    "explanation": "GitHub Projects (especialmente a nova versão) permite criar quadros (boards) e tabelas (tables) altamente personalizáveis para organizar e rastrear o trabalho, integrando-se diretamente com issues e PRs e permitindo automações."
  },
  {
    "id": 30,
    "text": "Qual é o principal benefício de usar 'labels' (etiquetas) como `bug`, `enhancement`, `documentation`, `priority:high` em issues e pull requests no GitHub?",
    "options": [
      { "id": "a", "text": "Ajudar a categorizar, filtrar, priorizar e gerenciar o trabalho. Elas fornecem uma maneira visual rápida de entender o tipo, status ou prioridade de um item, facilitando a triagem e o planejamento." },
      { "id": "b", "text": "Aumentar o limite de armazenamento do repositório para cada label criada." },
      { "id": "c", "text": "Atribuir automaticamente os itens a proprietários de código com base na label." },
      { "id": "d", "text": "Garantir que apenas usuários específicos possam comentar em itens com certas labels." }
    ],
    "correctAnswerId": "a",
    "explanation": "Labels são cruciais para organizar e facilitar a triagem e o gerenciamento de issues e PRs, permitindo que as equipes filtrem e priorizem o trabalho de forma eficaz."
  },
  {
    "id": 31,
    "text": "Uma equipe está planejando o lançamento da versão 2.0 de seu software e quer agrupar todas as issues e pull requests relacionados a esse lançamento para acompanhar o progresso em direção a uma data de entrega específica (ex: final do trimestre). Qual recurso do GitHub é ideal para isso?",
    "options": [
      { "id": "a", "text": "Criar um branch chamado 'v2.0' e fazer todos os commits nele." },
      { "id": "b", "text": "Utilizar 'milestones' (marcos). Milestones podem ter uma data de conclusão e agrupar issues e PRs, mostrando o progresso geral em direção a esse objetivo." },
      { "id": "c", "text": "Adicionar a label 'v2.0' a todos os itens e filtrar por essa label." },
      { "id": "d", "text": "Fixar (pin) todas as issues relevantes na página de issues." }
    ],
    "correctAnswerId": "b",
    "explanation": "Milestones são projetados para rastrear o progresso em direção a objetivos maiores ou lançamentos com uma data de conclusão, agrupando issues e PRs relacionados e mostrando uma barra de progresso."
  },
  {
    "id": 32,
    "text": "Um mantenedor de um projeto popular frequentemente responde a perguntas semelhantes nas issues, como 'Por favor, forneça os passos para reproduzir o bug' ou 'Consulte a documentação em [link]'. Para otimizar seu tempo, qual recurso do GitHub ele poderia usar para inserir rapidamente essas respostas padronizadas?",
    "options": [
      { "id": "a", "text": "Criar um Gist para cada resposta e copiar/colar o link do Gist." },
      { "id": "b", "text": "Configurar um workflow de GitHub Actions para responder automaticamente com base em palavras-chave." },
      { "id": "c", "text": "Editar o template de issue para incluir todas as respostas possíveis como comentários." },
      { "id": "d", "text": "Usar 'saved replies' (respostas salvas). Este recurso permite criar e armazenar respostas comuns que podem ser facilmente inseridas em comentários de issues e PRs." }
    ],
    "correctAnswerId": "d",
    "explanation": "Saved replies permitem que os usuários criem e reutilizem respostas comuns para comentários em issues e pull requests, economizando tempo e garantindo consistência."
  },
  {
    "id": 33,
    "text": "Como um gerente de projeto pode indicar qual membro da equipe é o principal responsável por resolver uma determinada issue no GitHub, e qual o benefício de fazer essa atribuição?",
    "options": [
      { "id": "a", "text": "Adicionando uma label com o nome do usuário, o que não cria uma atribuição formal." },
      { "id": "b", "text": "Atribuindo a issue ao usuário através da seção 'Assignees' (Responsáveis) na barra lateral da issue ou usando o comando `/assign @username`. Isso clarifica a responsabilidade e permite filtrar issues por responsável." },
      { "id": "c", "text": "Mencionando o nome do usuário no título da issue, o que não é uma prática padrão para atribuição." },
      { "id": "d", "text": "Pedindo ao usuário para comentar na issue que ele está trabalhando nela, o que é informal." }
    ],
    "correctAnswerId": "b",
    "explanation": "A funcionalidade 'Assignees' é a forma padrão e rastreável de designar responsabilidade por issues e pull requests, ajudando na organização e acompanhamento do trabalho."
  },
  {
    "id": 34,
    "text": "Ao configurar um GitHub Project (nova versão), quais são as duas principais opções de layout para visualizar os itens do projeto, e qual a vantagem de poder alternar entre elas?",
    "options": [
      { "id": "a", "text": "Apenas lista cronológica e calendário, limitando a visualização do fluxo." },
      { "id": "b", "text": "Gráfico de Gantt e nuvem de palavras, que são mais para análise do que para gerenciamento diário." },
      { "id": "c", "text": "Board (quadro Kanban) e Table (tabela). A alternância permite que diferentes membros da equipe visualizem os dados da forma mais conveniente para sua função (ex: quadro para fluxo, tabela para detalhes e campos personalizados)." },
      { "id": "d", "text": "Mapa mental e organograma, focados em estrutura e não em tarefas." }
    ],
    "correctAnswerId": "c",
    "explanation": "Os GitHub Projects mais recentes oferecem visualizações flexíveis, sendo as principais o layout de quadro (semelhante ao Kanban) para visualizar o fluxo de trabalho e o layout de tabela para uma visão mais detalhada e tabular dos itens."
  },
  {
    "id": 35,
    "text": "Sua organização tem um padrão de estrutura de projeto para novas aplicações web, incluindo arquivos de linting (`.eslintrc.js`), configuração de testes (`jest.config.js`), uma estrutura de pastas inicial (`/src`, `/public`, `/tests`) e até mesmo um workflow básico de CI (`.github/workflows/ci.yml`). Como você pode facilitar a criação de novos projetos seguindo esse padrão e garantir consistência entre as equipes?",
    "options": [
      { "id": "a", "text": "Manter um branch chamado 'template' no repositório principal e instruir as equipes a copiarem dele manualmente." },
      { "id": "b", "text": "Criar um repositório com a estrutura desejada e marcá-lo como um 'template repository' (repositório de modelo). Isso permite que novos repositórios sejam gerados a partir deste modelo, herdando sua estrutura de arquivos, pastas e, opcionalmente, todos os branches, incluindo o workflow de CI." },
      { "id": "c", "text": "Escrever um script local que cria a estrutura e compartilhá-lo entre as equipes para execução manual." },
      { "id": "d", "text": "Publicar a estrutura como um Gist e fornecer instruções sobre como replicá-la." }
    ],
    "correctAnswerId": "b",
    "explanation": "Marcar um repositório como um template permite que ele seja usado como base para criar novos repositórios, que herdarão sua estrutura de arquivos, pastas e opcionalmente, todos os branches, promovendo padronização e agilidade."
  },
  {
    "id": 36,
    "text": "Qual é o principal benefício de habilitar a Autenticação de Dois Fatores (2FA) na sua conta GitHub, e qual tipo de ameaça ela ajuda a mitigar?",
    "options": [
      { "id": "a", "text": "Desbloqueia temas de perfil exclusivos e aumenta a velocidade de clone." },
      { "id": "b", "text": "Permite criar um número ilimitado de repositórios privados gratuitamente." },
      { "id": "c", "text": "Adiciona uma camada extra significativa de segurança, exigindo uma segunda forma de verificação (além da senha) para login. Isso dificulta o acesso não autorizado mesmo que sua senha seja comprometida (ex: por phishing ou vazamento de dados)." },
      { "id": "d", "text": "Automatiza a resposta a issues e pull requests." }
    ],
    "correctAnswerId": "c",
    "explanation": "2FA é uma medida de segurança crucial que protege sua conta exigindo, por exemplo, um código de um aplicativo autenticador ou uma chave de segurança física, além da sua senha, mitigando o risco de acesso por credenciais roubadas."
  },
  {
    "id": 37,
    "text": "Uma equipe quer garantir que nenhum código seja mesclado ao branch `main` sem que pelo menos duas revisões sejam aprovadas, todos os testes de CI (definidos como 'status checks') passem, e que o autor do PR não possa aprovar seu próprio PR. Qual recurso do GitHub deve ser configurado para impor essas condições?",
    "options": [
      { "id": "a", "text": "GitHub Actions para enviar e-mails de alerta quando essas condições não são cumpridas." },
      { "id": "b", "text": "Regras de proteção de branch (branch protection rules). Essas regras podem ser configuradas para exigir revisões, status checks bem-sucedidos, impedir auto-aprovação, entre outras proteções." },
      { "id": "c", "text": "Milestones para o branch `main`, com tarefas para cada condição." },
      { "id": "d", "text": "Webhooks personalizados que chamam uma API externa para validar as condições." }
    ],
    "correctAnswerId": "b",
    "explanation": "As regras de proteção de branch permitem impor várias condições para merges, como revisões obrigatórias, verificações de status (CI/CD) bem-sucedidas, restrições de push direto e impedir que o autor aprove seu próprio PR."
  },
  {
    "id": 38,
    "text": "Qual dos seguintes NÃO é um nível de permissão padrão para colaboradores em um repositório GitHub, e qual seria uma permissão mais apropriada para alguém que precisa apenas reportar bugs e participar de discussões?",
    "options": [
      { "id": "a", "text": "Read (Leitura)" },
      { "id": "b", "text": "Write (Escrita)" },
      { "id": "c", "text": "Execute (Execução). Para reportar bugs e discutir, a permissão 'Triage' (ou Read, se Triage não for suficiente para criar issues) é mais apropriada que Write ou Admin." },
      { "id": "d", "text": "Admin (Administração)" }
    ],
    "correctAnswerId": "c",
    "explanation": "Os níveis de permissão comuns são Read, Triage, Write, Maintain, e Admin. 'Execute' não é um nível de permissão de repositório padrão. 'Triage' permite gerenciar issues e pull requests sem acesso de escrita ao código."
  },
  {
    "id": 39,
    "text": "Qual configuração de visibilidade de um repositório permite que qualquer pessoa na internet veja o código e abra issues, mas apenas colaboradores explicitamente adicionados possam fazer push de alterações ou mesclar Pull Requests?",
    "options": [
      { "id": "a", "text": "Privado (Private), que restringe toda a visibilidade e contribuição." },
      { "id": "b", "text": "Arquivado (Archived), que torna o repositório somente leitura para todos." },
      { "id": "c", "text": "Interno (Internal), visível apenas para membros da organização." },
      { "id": "d", "text": "Público (Public). Repositórios públicos são visíveis para todos, permitindo que qualquer um abra issues e PRs (de forks), mas as permissões de escrita direta e merge são controladas." }
    ],
    "correctAnswerId": "d",
    "explanation": "Repositórios públicos são visíveis para todos, fomentando a colaboração aberta, mas as permissões de escrita direta no repositório são controladas pelos mantenedores."
  },
  {
    "id": 40,
    "text": "No contexto do GitHub Enterprise Cloud, o que caracteriza os 'Enterprise Managed Users (EMUs)', e qual o principal benefício para a empresa ao adotá-los?",
    "options": [
      { "id": "a", "text": "São contas de usuário que pertencem à empresa e são provisionadas e gerenciadas através de um provedor de identidade (IdP) externo (ex: Azure AD, Okta). O principal benefício é o controle centralizado da identidade do usuário, ciclo de vida da conta e conformidade com políticas de segurança da empresa." },
      { "id": "b", "text": "São usuários que pagam uma taxa extra por suporte premium e acesso prioritário a novas funcionalidades." },
      { "id": "c", "text": "São os proprietários da organização Enterprise, com permissões irrestritas sobre todas as configurações." },
      { "id": "d", "text": "São contas de serviço (bots) com permissões elevadas, usadas para automação de tarefas administrativas." }
    ],
    "correctAnswerId": "a",
    "explanation": "EMUs dão às empresas controle total sobre as identidades de seus usuários no GitHub, incluindo criação, desativação e gerenciamento de acesso, integrados ao seu sistema de identidade corporativo, o que é crucial para segurança e conformidade."
  },
  {
    "id": 41,
    "text": "Um líder de equipe deseja analisar a frequência de commits, a atividade de pull requests (tempo para merge, discussões), e identificar possíveis gargalos no processo de desenvolvimento, como PRs que ficam muito tempo abertos. Qual área do GitHub ele deve consultar para obter esses dados analíticos?",
    "options": [
      { "id": "a", "text": "A lista de 'Watchers' e 'Stars' do repositório, que indicam interesse externo." },
      { "id": "b", "text": "A seção 'Insights' (ou 'Percepções') do repositório. Ela oferece gráficos e dados sobre commits, pull requests (incluindo tempo de abertura, merges), atividade de contribuidores, frequência de código, e mais." },
      { "id": "c", "text": "A aba 'Actions' para verificar o status dos workflows, que foca na CI/CD." },
      { "id": "d", "text": "As configurações de 'Branch protection rules', que definem políticas mas não analisam o fluxo." }
    ],
    "correctAnswerId": "b",
    "explanation": "Repository Insights (Percepções do Repositório) fornecem gráficos e dados sobre commits, pull requests, atividade de contribuidores, tráfego e muito mais, ajudando a entender a dinâmica do projeto e identificar áreas de melhoria."
  },
  {
    "id": 42,
    "text": "Qual princípio fundamental define um software como 'open source' (código aberto), e qual a importância de uma licença open source nesse contexto?",
    "options": [
      { "id": "a", "text": "O software só pode ser mantido por uma única organização para garantir a qualidade." },
      { "id": "b", "text": "O código-fonte do software é disponibilizado publicamente, permitindo que qualquer pessoa o veja, use, modifique e distribua. A licença open source (ex: MIT, GPL) define legalmente esses termos e condições." },
      { "id": "c", "text": "O software deve ser obrigatoriamente gratuito para uso comercial e não pode ter suporte pago." },
      { "id": "d", "text": "O software é desenvolvido exclusivamente por voluntários e não pode ser usado por empresas." }
    ],
    "correctAnswerId": "b",
    "explanation": "A disponibilidade e liberdade de acesso, uso, modificação e distribuição do código-fonte são centrais para a definição de open source. A licença associada (como MIT, GPL, Apache) é o que formaliza essas permissões e obrigações."
  },
  {
    "id": 43,
    "text": "Como o GitHub Sponsors contribui para o ecossistema de código aberto, e qual o impacto disso para os desenvolvedores que dedicam tempo a esses projetos?",
    "options": [
      { "id": "a", "text": "Organizando conferências anuais sobre código aberto e oferecendo prêmios." },
      { "id": "b", "text": "Fornecendo servidores de hospedagem gratuitos para todos os projetos open source, o que o GitHub já faz." },
      { "id": "c", "text": "Permitindo que indivíduos e organizações apoiem financeiramente desenvolvedores e projetos de código aberto. Isso ajuda a sustentar o trabalho dos mantenedores, permitindo que dediquem mais tempo e recursos aos projetos." },
      { "id": "d", "text": "Oferecendo certificações gratuitas e exclusivas para desenvolvedores open source patrocinados." }
    ],
    "correctAnswerId": "c",
    "explanation": "GitHub Sponsors facilita o patrocínio direto a mantenedores de código aberto, ajudando a sustentar seus esforços, cobrir custos e, potencialmente, permitir que trabalhem em open source de forma mais dedicada."
  },
  {
    "id": 44,
    "text": "Uma empresa de grande porte deseja aplicar as melhores práticas de colaboração e reuso de código, típicas de projetos open source (como revisões de PRs abertas, documentação clara, descoberta de projetos internos), em seus projetos internos e proprietários, visando quebrar silos entre equipes. Qual conceito descreve essa abordagem?",
    "options": [
      { "id": "a", "text": "OuterSource, que foca em externalizar projetos internos." },
      { "id": "b", "text": "Closed Source Development, que é o modelo tradicional proprietário." },
      { "id": "c", "text": "InnerSource. É a aplicação de princípios e práticas de desenvolvimento open source dentro de uma organização para seus próprios projetos, fomentando colaboração e reuso internos." },
      { "id": "d", "text": "Proprietary Collaboration Model, um termo genérico que não descreve essa prática específica." }
    ],
    "correctAnswerId": "c",
    "explanation": "InnerSource é a aplicação de princípios e práticas de desenvolvimento open source (transparência, colaboração, reuso, comunidade interna) dentro de uma organização para seus próprios projetos, melhorando a eficiência e a qualidade."
  },
  {
    "id": 45,
    "text": "Qual é a distinção crucial entre 'InnerSource' e 'open source' em termos de acesso ao código-fonte e à comunidade de colaboradores?",
    "options": [
      { "id": "a", "text": "Open source é focado em lucro através de licenças permissivas, InnerSource em pesquisa acadêmica." },
      { "id": "b", "text": "Projetos InnerSource não podem usar Git ou GitHub, apenas sistemas de controle de versão proprietários." },
      { "id": "c", "text": "InnerSource sempre utiliza licenças mais restritivas que open source, proibindo qualquer modificação." },
      { "id": "d", "text": "Open source envolve colaboração pública e código acessível globalmente (sujeito à licença). InnerSource restringe a colaboração e o acesso ao código aos membros da organização proprietária, aplicando as mesmas práticas colaborativas internamente." }
    ],
    "correctAnswerId": "d",
    "explanation": "A principal diferença é o escopo e o acesso: open source é externo e público; InnerSource é interno e restrito à organização, embora compartilhe muitas metodologias de colaboração e transparência (dentro dos limites da empresa)."
  },
  {
    "id": 46,
    "text": "Onde um desenvolvedor pode encontrar e instalar ferramentas de terceiros, como sistemas de CI/CD (ex: CircleCI, Travis CI), scanners de segurança (ex: Snyk, SonarCloud), ou ferramentas de gerenciamento de projetos (ex: ZenHub), que se integram ao seu fluxo de trabalho no GitHub?",
    "options": [
      { "id": "a", "text": "Na documentação oficial do Git, que foca apenas nos comandos Git." },
      { "id": "b", "text": "No GitHub Marketplace. Ele oferece uma vasta gama de GitHub Apps e Actions que podem ser instaladas para estender a funcionalidade do GitHub e se integrar aos fluxos de desenvolvimento." },
      { "id": "c", "text": "Solicitando diretamente ao suporte do GitHub, que pode orientar, mas não é o local de instalação." },
      { "id": "d", "text": "Através de GitHub Gists populares que contenham scripts de integração." }
    ],
    "correctAnswerId": "b",
    "explanation": "O GitHub Marketplace é a plataforma oficial para descobrir, comprar e instalar aplicativos e ações que estendem a funcionalidade do GitHub e se integram aos fluxos de desenvolvimento, incluindo CI/CD, segurança, etc."
  },
  {
    "id": 47,
    "text": "Para garantir que os relatórios de bugs em um projeto sejam consistentes e contenham informações essenciais (como passos para reproduzir, versão do software, ambiente, logs relevantes), qual recurso do GitHub é mais eficaz para guiar os usuários na submissão?",
    "options": [
      { "id": "a", "text": "Usar a funcionalidade de 'milestones' para bugs, que ajuda a agrupar, mas não a formatar." },
      { "id": "b", "text": "Configurar um webhook para validar cada nova issue externamente." },
      { "id": "c", "text": "Criar 'issue templates' (modelos de issue em Markdown) ou 'issue forms' (formulários de issue em YAML, mais estruturados). Ambos permitem predefinir seções e campos para o relatório." },
      { "id": "d", "text": "Fixar (pin) uma issue exemplo no topo da lista e pedir para os usuários seguirem o formato." }
    ],
    "correctAnswerId": "c",
    "explanation": "Issue templates (Markdown) e issue forms (YAML, mais estruturados com campos específicos como dropdowns, checkboxes) permitem que os mantenedores definam campos e seções que os usuários devem preencher ao criar issues, garantindo a coleta de informações padronizadas."
  },
  {
    "id": 48,
    "text": "Um projeto quer que todos os Pull Requests incluam uma checklist para o contribuidor confirmar que os testes foram executados localmente, a documentação foi atualizada e as diretrizes de contribuição foram seguidas. Como isso pode ser padronizado na descrição de cada novo PR?",
    "options": [
      { "id": "a", "text": "Configurando CODEOWNERS para adicionar a checklist automaticamente." },
      { "id": "b", "text": "Editando manualmente cada descrição de PR após a criação, o que é ineficiente." },
      { "id": "c", "text": "Criando um 'pull request template' (arquivo `PULL_REQUEST_TEMPLATE.md` ou dentro de `.github/`). O conteúdo deste template, incluindo a checklist em Markdown, será automaticamente preenchido na descrição de novos PRs." },
      { "id": "d", "text": "Usando uma GitHub Action para adicionar a checklist como comentário após a criação do PR." }
    ],
    "correctAnswerId": "c",
    "explanation": "Pull request templates (arquivos `PULL_REQUEST_TEMPLATE.md` ou dentro de `.github/`) preenchem automaticamente a descrição de novos PRs com o conteúdo do modelo, incluindo checklists, seções para descrição, etc., promovendo consistência."
  },
  {
    "id": 49,
    "text": "Qual é o resultado principal de se fazer 'fork' de um repositório no GitHub, e como isso se relaciona com o processo de contribuição para projetos open source?",
    "options": [
      { "id": "a", "text": "Um novo branch é criado no repositório original com o seu nome de usuário, onde você pode commitar diretamente." },
      { "id": "b", "text": "Você recebe notificações de todas as atividades no repositório original e se torna um colaborador." },
      { "id": "c", "text": "O repositório original é movido para a sua conta, e você se torna o novo proprietário." },
      { "id": "d", "text": "Uma cópia pessoal e independente do repositório (incluindo código e histórico de commits) é criada sob a sua conta GitHub. Isso permite que você faça alterações livremente em seu fork e depois proponha essas alterações ao projeto original através de um Pull Request." }
    ],
    "correctAnswerId": "d",
    "explanation": "Forking é essencial para o modelo de contribuição do GitHub. Você faz fork, clona seu fork, faz alterações, envia para seu fork e então abre um pull request para o repositório original ('upstream'). Isso permite contribuições sem dar acesso direto de escrita ao repositório original."
  },
  {
    "id": 50,
    "text": "Qual é um benefício de 'seguir' (follow) outros usuários ou organizações no GitHub, em termos de se manter atualizado com a comunidade e descobrir projetos?",
    "options": [
      { "id": "a", "text": "Permite editar os repositórios deles diretamente, sem necessidade de fork." },
      { "id": "b", "text": "Adiciona automaticamente todos os repositórios deles à sua lista de 'starred'." },
      { "id": "c", "text": "Ajuda a descobrir novos projetos e atividades relevantes em sua rede, pois as atividades públicas deles (como criar repositórios, dar star, etc.) podem aparecer no seu dashboard pessoal (feed de atividades)." },
      { "id": "d", "text": "Garante que eles sigam você de volta, aumentando sua popularidade." }
    ],
    "correctAnswerId": "c",
    "explanation": "Seguir usuários e organizações personaliza seu feed de atividades no GitHub, ajudando você a se manter atualizado sobre projetos e pessoas de seu interesse e a descobrir novas iniciativas."
  },
  {
    "id": 51,
    "text": "Quais são os três tipos principais de contas GitHub, e qual a principal distinção entre uma conta 'Organization' e uma conta 'Enterprise'?",
    "options": [
      { "id": "a", "text": "Developer, Tester, Manager; a distinção é o nível de acesso técnico." },
      { "id": "b", "text": "Free, Pro, Business; a distinção é o custo e os recursos para indivíduos." },
      { "id": "c", "text": "Student, Educator, Alumni; a distinção é o status educacional." },
      { "id": "d", "text": "Personal (Pessoal), Organization (Organização), Enterprise (Empresarial). Contas de Organização são para colaboração em equipe. Contas Enterprise oferecem recursos avançados de segurança (como SAML SSO, EMUs), administração, conformidade e opções de deployment (Cloud ou Server) para grandes empresas, além do que é oferecido em contas de Organização." }
    ],
    "correctAnswerId": "d",
    "explanation": "Contas Pessoais são para indivíduos. Contas de Organização são para colaboração em equipe com recursos como times e permissões granulares. Contas Enterprise adicionam camadas de segurança, administração e conformidade para necessidades corporativas complexas."
  },
  {
    "id": 52,
    "text": "Ao redigir um comentário em uma Issue ou Pull Request no GitHub, onde geralmente se encontra a barra de ferramentas de formatação Markdown, e qual sua utilidade?",
    "options": [
      { "id": "a", "text": "Em um menu suspenso acessível clicando com o botão direito na caixa de texto." },
      { "id": "b", "text": "Integrada diretamente acima da caixa de texto do comentário, oferecendo botões para negrito, itálico, listas, links, citações, etc. Sua utilidade é facilitar a aplicação de estilos Markdown sem precisar memorizar toda a sintaxe." },
      { "id": "c", "text": "Nas configurações do perfil do usuário, onde pode ser ativada globalmente." },
      { "id": "d", "text": "Apenas no aplicativo GitHub Desktop, não na interface web." }
    ],
    "correctAnswerId": "b",
    "explanation": "O GitHub fornece uma barra de ferramentas de formatação WYSIWYG-like para Markdown em campos de texto, facilitando a aplicação de estilos e a pré-visualização do conteúdo."
  },
  {
    "id": 53,
    "text": "Qual é a principal proposta de valor do GitHub Desktop para um desenvolvedor que já conhece os comandos Git, mas trabalha em múltiplos projetos e branches simultaneamente?",
    "options": [
      { "id": "a", "text": "Substituir completamente a necessidade de usar o site github.com para gerenciamento de issues." },
      { "id": "b", "text": "Automatizar a escrita de mensagens de commit usando IA e templates." },
      { "id": "c", "text": "Fornecer uma interface gráfica para operações Git comuns, o que pode ser mais visual e intuitivo para gerenciar branches (visualizar o grafo, alternar, mesclar), visualizar diffs de forma clara, e fazer commits. Ajuda a ter uma visão geral do estado de múltiplos repositórios." },
      { "id": "d", "text": "Oferecer um editor de código integrado mais poderoso que o VS Code ou outros IDEs." }
    ],
    "correctAnswerId": "c",
    "explanation": "GitHub Desktop simplifica o fluxo de trabalho Git através de uma interface visual, tornando tarefas como commit, push, pull, merge e, especialmente, a visualização e gerenciamento de branches e alterações mais acessíveis e rápidas."
  },
  {
    "id": 54,
    "text": "Um gerente de equipe está viajando e precisa aprovar um Pull Request urgente que desbloqueia outros membros da equipe. Qual funcionalidade do GitHub Mobile é mais relevante para essa tarefa, permitindo uma ação rápida e informada?",
    "options": [
      { "id": "a", "text": "A possibilidade de revisar o código (diffs), ler comentários, ver o status dos checks e fazer o merge de pull requests diretamente do aplicativo." },
      { "id": "b", "text": "A capacidade de editar arquivos de configuração do repositório, como `CODEOWNERS`." },
      { "id": "c", "text": "Iniciar um GitHub Codespace para testar as alterações em um ambiente completo." },
      { "id": "d", "text": "Configurar novos workflows do GitHub Actions para automatizar a aprovação." }
    ],
    "correctAnswerId": "a",
    "explanation": "O GitHub Mobile é otimizado para tarefas de colaboração e gerenciamento em trânsito, como revisar e mesclar PRs, gerenciar issues e notificações, tornando-o ideal para aprovações urgentes."
  },
  {
    "id": 55,
    "text": "No Git, um 'remote' como 'origin' tipicamente se refere a quê, e como ele é estabelecido ao clonar um repositório do GitHub?",
    "options": [
      { "id": "a", "text": "Um arquivo de configuração local que define as preferências do usuário Git para cores e aliases." },
      { "id": "b", "text": "O branch principal do repositório (geralmente `main` ou `master`) no servidor." },
      { "id": "c", "text": "Uma cópia de segurança criptografada do seu repositório, armazenada localmente." },
      { "id": "d", "text": "Um apelido para a URL de um repositório hospedado em um servidor (como o GitHub). Ao usar `git clone`, o Git automaticamente configura um remote chamado 'origin' apontando para a URL de onde o repositório foi clonado, facilitando a sincronização futura (`push`/`pull`)." }
    ],
    "correctAnswerId": "d",
    "explanation": "Remotes são ponteiros para outros repositórios. 'origin' é o nome padrão dado ao remote quando você clona um repositório, apontando para a URL de onde foi clonado, para facilitar a comunicação entre o repositório local e o remoto."
  },
  {
    "id": 56,
    "text": "Para que um usuário de seu software saiba explicitamente o que ele pode e não pode fazer com o código (ex: usar em projetos comerciais, modificar, redistribuir, obrigações de atribuição), qual arquivo é indispensável em seu repositório e por que ele deve ser claro?",
    "options": [
      { "id": "a", "text": "O `README.md` com uma seção sobre uso, que é informativa mas não legalmente vinculativa." },
      { "id": "b", "text": "O arquivo `LICENSE` (ou `LICENSE.md`). Ele é o documento legal que define os termos sob os quais o software é licenciado. Clareza evita ambiguidades e potenciais disputas legais." },
      { "id": "c", "text": "Um `SECURITY.md` detalhado, que foca em vulnerabilidades." },
      { "id": "d", "text": "Um arquivo `TERMS_OF_SERVICE.md`, mais comum para serviços online do que para software distribuído." }
    ],
    "correctAnswerId": "b",
    "explanation": "O arquivo LICENSE é o documento legal que define os termos sob os quais o software é licenciado para uso, modificação e distribuição. Sua clareza é fundamental para a conformidade legal."
  },
  {
    "id": 57,
    "text": "O GitHub às vezes oferece 'Feature Previews'. Qual o propósito dessa funcionalidade para os usuários, e como eles geralmente acessam essas prévias?",
    "options": [
      { "id": "a", "text": "Um modo de demonstração para novos usuários do GitHub, mostrando funcionalidades básicas." },
      { "id": "b", "text": "Permitir que os usuários paguem para ter acesso antecipado a todos os novos recursos, como um serviço premium." },
      { "id": "c", "text": "Dar aos usuários a oportunidade de habilitar e testar novos recursos do GitHub que ainda estão em desenvolvimento (beta) e fornecer feedback antes do lançamento oficial. O acesso é geralmente através das configurações do perfil do usuário ou da organização." },
      { "id": "d", "text": "Visualizar como um repositório privado apareceria se fosse público, sem alterar sua visibilidade real." }
    ],
    "correctAnswerId": "c",
    "explanation": "Feature Previews permitem que a comunidade experimente funcionalidades em estágio beta e ajude o GitHub a refinar esses recursos com base no feedback do usuário. Elas são ativadas opcionalmente pelo usuário."
  },
  {
    "id": 58,
    "text": "Ao visualizar uma issue no GitHub que descreve um bug, qual é a maneira mais integrada e eficiente de iniciar o trabalho de correção, garantindo que o novo branch seja associado à issue?",
    "options": [
      { "id": "a", "text": "Copiar o título da issue e usá-lo como mensagem do primeiro commit em um branch criado manualmente." },
      { "id": "b", "text": "Clonar o repositório e criar um branch manualmente com `git checkout -b fix/bug-name`, depois vincular manualmente ao PR." },
      { "id": "c", "text": "Utilizar a opção 'Create a branch' (Criar um branch) diretamente na página da issue. O GitHub frequentemente sugere um nome de branch relacionado à issue (ex: `numero-titulo-da-issue`) e pode automaticamente vincular o branch e futuros PRs à issue." },
      { "id": "d", "text": "Enviar um e-mail para a equipe de desenvolvimento solicitando a criação de um branch e a atribuição da issue." }
    ],
    "correctAnswerId": "c",
    "explanation": "O GitHub oferece uma maneira conveniente de criar um branch diretamente de uma issue. Isso não apenas economiza tempo, mas também pode criar automaticamente um link entre o branch e a issue, melhorando o rastreamento."
  },
  {
    "id": 59,
    "text": "Qual a principal vantagem de usar 'issue forms' (definidos via YAML na pasta `.github/ISSUE_TEMPLATE/`) sobre 'issue templates' (definidos via arquivos Markdown na mesma pasta) para coletar informações sobre bugs complexos?",
    "options": [
      { "id": "a", "text": "Issue forms são automaticamente traduzidos para múltiplos idiomas, enquanto templates Markdown não são." },
      { "id": "b", "text": "Issue forms oferecem campos estruturados (como dropdowns, caixas de seleção, campos de texto obrigatórios com validação básica) que guiam o usuário no preenchimento, garantindo dados mais consistentes e completos. Templates Markdown são mais de formato livre, dependendo da interpretação do usuário." },
      { "id": "c", "text": "Apenas issue forms podem ser usados em repositórios privados; templates Markdown são apenas para públicos." },
      { "id": "d", "text": "Issue forms permitem anexar arquivos muito maiores do que os templates Markdown." }
    ],
    "correctAnswerId": "b",
    "explanation": "Issue forms, configurados com YAML, proporcionam uma experiência de submissão mais guiada e estruturada, com tipos de entrada definidos (texto, dropdown, checkboxes), validações e campos obrigatórios, ajudando a coletar informações precisas e consistentes."
  },
  {
    "id": 60,
    "text": "Em um Pull Request, o 'base branch' representa o branch _____, e o 'compare branch' (ou 'head branch') representa o branch _____. Qual é o objetivo do PR em relação a esses dois branches?",
    "options": [
      { "id": "a", "text": "local onde o PR foi criado; remoto para onde será enviado." },
      { "id": "b", "text": "que contém as novas alterações (ex: `feature-branch`); onde as alterações serão integradas (ex: `main`). O objetivo é mesclar o `base` no `compare`." },
      { "id": "c", "text": "mais recente com atividade; mais antigo e estável." },
      { "id": "d", "text": "onde as alterações serão integradas (ex: `main`); que contém as novas alterações (ex: `feature-branch`). O objetivo do PR é propor a mesclagem (merge) das alterações do `compare branch` no `base branch`." }
    ],
    "correctAnswerId": "d",
    "explanation": "O Pull Request é uma solicitação para mesclar as alterações do 'compare branch' (onde o desenvolvimento foi feito, também chamado de 'head branch') no 'base branch' (o destino das alterações, como `main` ou `develop`)."
  },
  {
    "id": 61,
    "text": "Um Pull Request no GitHub tem uma aba 'Checks'. Qual informação crítica essa aba fornece durante o processo de revisão de código, e por que ela é importante para a integração contínua?",
    "options": [
      { "id": "a", "text": "Uma lista de todos os usuários que visualizaram o PR e o tempo gasto por cada um." },
      { "id": "b", "text": "O status de verificações automatizadas (como testes de CI/CD, linters, análise de segurança) configuradas para rodar no código do PR. É crucial para a CI, pois indica se as alterações propostas quebram o build ou introduzem problemas." },
      { "id": "c", "text": "Uma contagem de quantos commits foram feitos no PR e o tamanho de cada um." },
      { "id": "d", "text": "Sugestões de branches alternativos para o merge, baseadas na popularidade dos branches." }
    ],
    "correctAnswerId": "b",
    "explanation": "A aba 'Checks' é vital para a integração contínua, mostrando se o código proposto passa nos testes automatizados e outras verificações de qualidade (configuradas via GitHub Actions ou integrações de terceiros) antes do merge."
  },
  {
    "id": 62,
    "text": "Se um Pull Request exibe o status 'Closed' e não 'Merged', o que isso geralmente indica sobre o destino das alterações propostas?",
    "options": [
      { "id": "a", "text": "O Pull Request foi convertido em um 'Draft' e está aguardando mais trabalho." },
      { "id": "b", "text": "As alterações foram automaticamente integradas após um período de inatividade e aprovação implícita." },
      { "id": "c", "text": "O Pull Request foi fechado sem que suas alterações fossem integradas ao base branch. Isso pode ocorrer porque foi rejeitado, substituído por outro PR, tornou-se obsoleto, ou o trabalho foi abandonado." },
      { "id": "d", "text": "O Pull Request ainda está aguardando a aprovação final de um CODEOWNER, e 'Closed' é um estado intermediário." }
    ],
    "correctAnswerId": "c",
    "explanation": "Um PR 'Closed' significa que ele não foi mesclado. As alterações contidas nele não foram incorporadas ao branch base através daquele PR específico. A aba 'Conversation' geralmente contém o contexto da decisão."
  },
  {
    "id": 63,
    "text": "Durante uma revisão de código em um Pull Request, se um revisor seleciona a opção 'Request changes' (Solicitar alterações), qual é a implicação para o PR, especialmente se houver regras de proteção de branch configuradas?",
    "options": [
      { "id": "a", "text": "O PR é automaticamente mesclado, mas com um aviso sobre as alterações solicitadas para referência futura." },
      { "id": "b", "text": "Isso geralmente bloqueia o merge do PR (se as regras de proteção de branch estiverem configuradas para exigir aprovação ou resolução de solicitações de mudança) e indica ao autor que são necessárias modificações antes que o PR possa ser aprovado e mesclado." },
      { "id": "c", "text": "O revisor está apenas fazendo um comentário informativo, sem impacto direto no status de mergeabilidade do PR." },
      { "id": "d", "text": "O PR é aprovado condicionalmente, e o autor pode mesclá-lo a qualquer momento, assumindo a responsabilidade pelas alterações." }
    ],
    "correctAnswerId": "b",
    "explanation": "'Request changes' é uma forma formal de indicar que o PR não deve ser mesclado até que as preocupações do revisor sejam abordadas. Frequentemente, impede o merge se as proteções de branch exigirem aprovação ou que todas as solicitações de alteração sejam resolvidas."
  },
  {
    "id": 64,
    "text": "Se uma discussão em GitHub Discussions sobre uma nova ideia de funcionalidade evolui para um ponto onde a equipe concorda que a ideia deve ser implementada e rastreada como um item de trabalho, qual funcionalidade do GitHub permite essa transição de forma integrada?",
    "options": [
      { "id": "a", "text": "Arquivar a discussão e criar uma nova issue manualmente, copiando o conteúdo relevante." },
      { "id": "b", "text": "A capacidade de converter a discussão (ou um comentário específico nela) em uma nova Issue. Isso preserva o contexto da discussão e facilita o início do rastreamento do trabalho." },
      { "id": "c", "text": "Vincular a discussão a um Milestone existente, o que não cria um item de trabalho rastreável." },
      { "id": "d", "text": "Fixar a discussão no topo da lista para que todos vejam que ela precisa ser implementada." }
    ],
    "correctAnswerId": "b",
    "explanation": "GitHub permite converter discussões ou comentários de discussões em issues, facilitando o rastreamento de trabalho acionável que surge de conversas e mantendo o link para o contexto original."
  },
  {
    "id": 65,
    "text": "Você foi mencionado (@seuUsuario) em um comentário de uma issue em um repositório que você não está 'watching' (observando). Você normalmente receberá uma notificação sobre essa menção, e como você pode gerenciar essas notificações?",
    "options": [
      { "id": "a", "text": "Apenas se a menção for no branch principal e você for um CODEOWNER." },
      { "id": "b", "text": "Não, você só recebe notificações de issues em repositórios que está 'watching' ou participando ativamente." },
      { "id": "c", "text": "Sim, o GitHub geralmente notifica sobre @mentions diretas, independentemente do status de 'watching' do repositório. Você pode gerenciar suas configurações de notificação (ex: via email, web) na seção de Notificações do seu perfil." },
      { "id": "d", "text": "Apenas se você for o proprietário do repositório ou da organização." }
    ],
    "correctAnswerId": "c",
    "explanation": "As @mentions são uma forma de chamar a atenção de usuários específicos e, por padrão, geram notificações para o usuário mencionado. As configurações de notificação permitem personalizar como e onde você recebe essas atualizações."
  },
  {
    "id": 66,
    "text": "Para um projeto que precisa de uma documentação mais extensa e estruturada do que um único arquivo README.md pode oferecer, como guias de API, tutoriais detalhados, e FAQs, qual recurso do repositório GitHub é mais adequado e permite colaboração na edição?",
    "options": [
      { "id": "a", "text": "GitHub Gists, criando um Gist para cada página de documentação." },
      { "id": "b", "text": "A Wiki do repositório. Wikis são projetadas para hospedar documentação mais elaborada, com múltiplas páginas, navegação (incluindo sidebars personalizáveis), controle de versão para as páginas e permissões de edição colaborativa." },
      { "id": "c", "text": "Múltiplos arquivos Markdown na raiz do repositório, o que pode dificultar a navegação." },
      { "id": "d", "text": "GitHub Projects, usando cards para cada seção da documentação." }
    ],
    "correctAnswerId": "b",
    "explanation": "As Wikis do GitHub são projetadas para hospedar documentação mais elaborada, com múltiplas páginas, navegação e colaboração na edição, complementando o README. Elas são versionadas e podem ter permissões de acesso controladas."
  },
  {
    "id": 67,
    "text": "Qual das seguintes atividades NÃO é uma forma comum de acionar (trigger) um workflow do GitHub Actions, e qual seria um exemplo de gatilho baseado em tempo?",
    "options": [
      { "id": "a", "text": "Um `push` para um branch específico ou a criação de uma tag." },
      { "id": "b", "text": "A abertura, edição ou fechamento de um `pull_request` ou `issue`." },
      { "id": "c", "text": "Um usuário dando 'star' no repositório ou fazendo um 'fork'. Um exemplo de gatilho baseado em tempo é `schedule`, usando sintaxe cron para execuções periódicas." },
      { "id": "d", "text": "Um `workflow_dispatch`, que permite acionar o workflow manualmente pela interface do GitHub." }
    ],
    "correctAnswerId": "c",
    "explanation": "Eventos comuns que acionam workflows incluem `push`, `pull_request`, `schedule`, `workflow_dispatch`, `issues`, etc. Dar 'star' ou fazer 'fork' não são eventos gatilho padrão para Actions. `schedule` é o gatilho para tarefas agendadas."
  },
  {
    "id": 68,
    "text": "Para utilizar o GitHub Copilot em seu IDE (como VS Code), quais são os pré-requisitos essenciais, e o Copilot envia seu código para algum lugar?",
    "options": [
      { "id": "a", "text": "Ser administrador do repositório no qual você está trabalhando e ter um token de acesso pessoal." },
      { "id": "b", "text": "Ter uma assinatura ativa do GitHub Copilot (individual ou via organização) e instalar a extensão do GitHub Copilot no IDE. O Copilot envia trechos de contexto do seu código para os servidores do GitHub para gerar sugestões." },
      { "id": "c", "text": "Configurar um arquivo `.copilotignore` na raiz do projeto e usar GitHub Enterprise." },
      { "id": "d", "text": "Possuir uma conta GitHub Pro e usar apenas repositórios públicos." }
    ],
    "correctAnswerId": "b",
    "explanation": "O GitHub Copilot requer uma licença ativa e a instalação da extensão apropriada no IDE. Ele envia contexto do código (o arquivo atual e, às vezes, abas abertas relacionadas) para gerar sugestões, mas não armazena seu código privado permanentemente nos servidores para treinar modelos públicos."
  },
  {
    "id": 69,
    "text": "Um desenvolvedor está usando um GitHub Codespace. Após terminar o trabalho do dia, ele quer garantir que não será cobrado pelo tempo de computação ocioso, mas quer retomar o trabalho no dia seguinte com o ambiente e arquivos intactos. Qual ação ele deve tomar, e qual a diferença para excluir o Codespace?",
    "options": [
      { "id": "a", "text": "Desconectar o VS Code do Codespace, o que não para a cobrança." },
      { "id": "b", "text": "Fazer commit de todas as alterações e fechar a aba do navegador, o que também não para a cobrança." },
      { "id": "c", "text": "Parar (Stop) o Codespace. Isso interrompe a cobrança por tempo de computação, mas preserva o estado do ambiente (arquivos, extensões, etc.) para que possa ser retomado. Excluir o Codespace apaga permanentemente o ambiente e seus dados." },
      { "id": "d", "text": "Excluir o Codespace e criar um novo no dia seguinte a partir do último commit, perdendo qualquer estado não commitado." }
    ],
    "correctAnswerId": "c",
    "explanation": "Parar um Codespace interrompe a cobrança por tempo de computação, mas preserva o estado do ambiente (arquivos, extensões, etc.) para que possa ser retomado posteriormente. Excluir remove o ambiente e seus dados."
  },
  {
    "id": 70,
    "text": "Como o arquivo `.devcontainer/devcontainer.json` contribui para a colaboração e a consistência do ambiente de desenvolvimento em um projeto usando GitHub Codespaces?",
    "options": [
      { "id": "a", "text": "Ele define as regras de automação para os GitHub Actions executados a partir do Codespace, substituindo os arquivos de workflow." },
      { "id": "b", "text": "Ele armazena os segredos e tokens de API necessários para o Codespace interagir com serviços externos, de forma visível para todos." },
      { "id": "c", "text": "Ele permite que o projeto defina um ambiente de desenvolvimento padronizado e reproduzível (imagem Docker, extensões VS Code, configurações, tasks pós-criação, etc.) para todos os usuários do Codespace. Isso garante que todos trabalhem com as mesmas ferramentas e configurações." },
      { "id": "d", "text": "Ele lista todos os contribuidores ativos e suas permissões específicas dentro do Codespace." }
    ],
    "correctAnswerId": "c",
    "explanation": "O `devcontainer.json` é fundamental para a especificação de 'Development Containers', garantindo que todos os desenvolvedores (ou instâncias de Codespace) tenham um ambiente consistente e configurado, reduzindo problemas de 'funciona na minha máquina'."
  },
  {
    "id": 71,
    "text": "Qual é a principal diferença funcional entre usar o editor github.dev (acessado ao pressionar '.') em um repositório e iniciar um GitHub Codespace completo para esse mesmo repositório, especialmente em termos de capacidade de execução de código?",
    "options": [
      { "id": "a", "text": "github.dev só permite editar arquivos Markdown e texto simples, enquanto Codespaces permite editar qualquer tipo de arquivo de código." },
      { "id": "b", "text": "github.dev é um editor web leve para navegação, edição e commit de arquivos, mas não fornece um ambiente de execução (terminal, depurador, capacidade de compilar código). Codespaces oferecem um ambiente de desenvolvimento completo na nuvem com esses recursos computacionais." },
      { "id": "c", "text": "Apenas Codespaces permitem a colaboração em tempo real com outros usuários; github.dev é estritamente para uso individual." },
      { "id": "d", "text": "github.dev é um recurso exclusivo para contas GitHub Enterprise, enquanto Codespaces está disponível para todos os planos." }
    ],
    "correctAnswerId": "b",
    "explanation": "O github.dev é para edições rápidas e revisão baseadas em navegador, sem backend computacional. Para desenvolvimento completo, incluindo execução, depuração e acesso a terminal, um Codespace (que é um contêiner de desenvolvimento na nuvem) é necessário."
  },
  {
    "id": 72,
    "text": "Qual é uma vantagem chave de usar GitHub Projects (nova versão) para gerenciar tarefas e issues de um projeto, em comparação com uma lista de issues simples ou um quadro Kanban externo não integrado?",
    "options": [
      { "id": "a", "text": "Ele substitui a necessidade de usar Git para controle de versão, gerenciando o código diretamente." },
      { "id": "b", "text": "Sua profunda integração com issues e pull requests do GitHub, permitindo que sejam visualizados, agrupados, filtrados e automatizados em layouts personalizáveis como tabelas e quadros. Mudanças nas issues/PRs podem refletir automaticamente no Project." },
      { "id": "c", "text": "Ele envia automaticamente relatórios de progresso diários por e-mail para todos os stakeholders, sem necessidade de configuração." },
      { "id": "d", "text": "Ele só pode ser usado para planejar sprints de duas semanas, não para acompanhamento contínuo ou backlog." }
    ],
    "correctAnswerId": "b",
    "explanation": "GitHub Projects oferece uma ferramenta poderosa e flexível para planejamento e rastreamento de trabalho, diretamente conectada aos artefatos de desenvolvimento no GitHub, o que centraliza a informação e melhora a visibilidade."
  },
  {
    "id": 73,
    "text": "Comparado ao GitHub Projects (classic), qual é uma melhoria significativa na versão mais recente do GitHub Projects em termos de personalização e automação?",
    "options": [
      { "id": "a", "text": "A nova versão é mais simples, com menos opções de personalização para facilitar o uso por iniciantes." },
      { "id": "b", "text": "A versão classic permite mais de cinco layouts diferentes, enquanto a nova tem apenas quadro e tabela." },
      { "id": "c", "text": "Maior flexibilidade com layouts de tabela e quadro, a adição de campos personalizados (texto, número, data, seleção única, iteração), automação de fluxos de trabalho (ex: mover issue para 'Concluído' quando o PR é mesclado) e a capacidade de incluir issues de múltiplos repositórios em um único projeto." },
      { "id": "d", "text": "A nova versão é exclusivamente baseada em linha de comando, sem interface gráfica." }
    ],
    "correctAnswerId": "c",
    "explanation": "A versão mais recente de GitHub Projects é significativamente mais poderosa e flexível, oferecendo funcionalidades como campos personalizados, automação nativa e melhor integração para gerenciar trabalho em escala."
  },
  {
    "id": 74,
    "text": "Para uma empresa que utiliza GitHub Enterprise Cloud e deseja gerenciar centralmente as contas de seus desenvolvedores através de seu Provedor de Identidade (IdP) como Okta ou Azure AD, garantindo que o acesso seja provisionado e desprovisionado conforme o status do funcionário na empresa, qual tipo de conta de usuário é apropriado?",
    "options": [
      { "id": "a", "text": "Contas de Organização padrão, com convites manuais para cada funcionário." },
      { "id": "b", "text": "Enterprise Managed Users (EMUs). Estas são contas GitHub provisionadas e controladas pela empresa através de seu IdP, permitindo gerenciamento de identidade unificado e políticas de segurança consistentes." },
      { "id": "c", "text": "Contas de serviço (GitHub Apps) para cada desenvolvedor, gerenciadas por scripts." },
      { "id": "d", "text": "Contas Pessoais vinculadas à organização através de SSO SAML, mas ainda pertencentes ao indivíduo." }
    ],
    "correctAnswerId": "b",
    "explanation": "Enterprise Managed Users (EMUs) são contas GitHub que pertencem à empresa e são totalmente gerenciadas via IdP, oferecendo o mais alto nível de controle sobre as identidades dos usuários para conformidade e segurança."
  },
  {
    "id": 75,
    "text": "Qual o principal objetivo de configurar 'branch protection rules' (regras de proteção de branch) para o branch `main` de um repositório, e quais são alguns exemplos comuns dessas regras?",
    "options": [
      { "id": "a", "text": "Impedir a criação de novos branches a partir do `main` para manter a estabilidade." },
      { "id": "b", "text": "Garantir a estabilidade e qualidade do branch `main`. Exemplos incluem: exigir aprovações de pull requests (com número mínimo de revisores), requerer que status checks (testes de CI) passem antes do merge, restringir quem pode fazer push direto, e sincronizar com o branch base antes do merge." },
      { "id": "c", "text": "Aumentar a velocidade com que os pull requests são mesclados no `main`, pulando revisões." },
      { "id": "d", "text": "Arquivar automaticamente o branch `main` após um período de inatividade para economizar recursos." }
    ],
    "correctAnswerId": "b",
    "explanation": "As regras de proteção de branch são cruciais para proteger branches importantes (como `main` ou `develop`), aplicando um conjunto de verificações e requisitos antes que o código possa ser integrado, mantendo a qualidade e estabilidade."
  },
  {
    "id": 76,
    "text": "A aba 'Security' de um repositório no GitHub oferece várias ferramentas para ajudar a manter o código seguro. Qual das seguintes funcionalidades NÃO é tipicamente encontrada ou gerenciada diretamente através desta aba?",
    "options": [
      { "id": "a", "text": "Alertas do Dependabot para dependências vulneráveis e configuração de atualizações de segurança automáticas." },
      { "id": "b", "text": "Configuração de 'Code scanning' (varredura de código) com CodeQL ou ferramentas de terceiros." },
      { "id": "c", "text": "Gerenciamento de 'secrets' (segredos) para GitHub Actions e Codespaces." },
      { "id": "d", "text": "Estatísticas detalhadas de tráfego de clones e visualizações do repositório por período (ex: últimos 14 dias)." }
    ],
    "correctAnswerId": "d",
    "explanation": "Estatísticas de tráfego (clones, visualizações) são encontradas na aba 'Insights'. A aba 'Security' foca em políticas de segurança, alertas de vulnerabilidade (Dependabot), varredura de código (Code scanning), revisão de segurança e gerenciamento de segredos."
  },
  {
    "id": 77,
    "text": "Dentro de uma organização GitHub, qual é a principal vantagem de usar 'teams' (equipes) para gerenciar o acesso a repositórios, em vez de adicionar colaboradores individualmente a cada repositório?",
    "options": [
      { "id": "a", "text": "Cada equipe recebe um orçamento separado para usar GitHub Actions e Codespaces." },
      { "id": "b", "text": "Simplificar o gerenciamento de acesso: você concede permissões a uma equipe para múltiplos repositórios, e gerencia a associação de membros à equipe. Também permite menções em grupo (ex: `@minhaorganizacao/desenvolvedores`) para notificar todos os membros da equipe." },
      { "id": "c", "text": "Criar um repositório privado exclusivo para cada equipe, inacessível por outros membros da organização." },
      { "id": "d", "text": "Permitir que membros da equipe ignorem as regras de proteção de branch e façam pushes diretos." }
    ],
    "correctAnswerId": "b",
    "explanation": "Equipes são uma forma eficiente de organizar membros e gerenciar suas permissões em massa para repositórios, além de facilitar a comunicação através de @mentions de equipe. Isso simplifica a administração de acesso em organizações com muitos usuários e repositórios."
  },
  {
    "id": 78,
    "text": "Qual destes é um benefício fundamental que o movimento 'open source' traz para a inovação tecnológica global, e como o GitHub facilita esse benefício?",
    "options": [
      { "id": "a", "text": "Garante que todo software open source seja isento de bugs e mais seguro que software proprietário." },
      { "id": "b", "text": "Limita o uso de software open source apenas para fins não comerciais, protegendo desenvolvedores individuais." },
      { "id": "c", "text": "Promove a colaboração, o aprendizado compartilhado, a transparência no desenvolvimento e a capacidade de construir sobre o trabalho de outros. GitHub facilita isso fornecendo uma plataforma para hospedagem de código, controle de versão, rastreamento de issues, e ferramentas de colaboração." },
      { "id": "d", "text": "Reduz a necessidade de documentação de software, pois o código é autoexplicativo." }
    ],
    "correctAnswerId": "c",
    "explanation": "O modelo open source fomenta um ecossistema onde conhecimento e código são compartilhados, permitindo que a inovação ocorra de forma mais rápida e distribuída. GitHub é uma plataforma central para essa colaboração."
  },
  {
    "id": 79,
    "text": "O que é 'InnerSource' e como se relaciona com 'open source' em termos de práticas de desenvolvimento e acesso ao código?",
    "options": [
      { "id": "a", "text": "InnerSource é um concorrente direto do open source, focando em software proprietário e desenvolvimento fechado." },
      { "id": "b", "text": "InnerSource é a aplicação de práticas e da cultura de desenvolvimento open source (como colaboração, transparência, revisão por pares, reuso de código) dentro dos limites de uma única organização, para seus projetos internos. O código permanece proprietário e restrito à organização." },
      { "id": "c", "text": "InnerSource refere-se ao código-fonte interno das plataformas GitHub, que não é acessível ao público." },
      { "id": "d", "text": "Open source é para indivíduos e pequenas empresas, InnerSource é exclusivamente para grandes corporações multinacionais." }
    ],
    "correctAnswerId": "b",
    "explanation": "InnerSource busca aproveitar os benefícios da colaboração e eficiência do modelo open source (como revisões de código abertas internamente, componentes reutilizáveis, documentação compartilhada), mas aplicado a projetos e código que permanecem internos à organização."
  },
  {
    "id": 80,
    "text": "Qual é o propósito principal de um arquivo `CONTRIBUTING.md` bem elaborado em um projeto open source, e que tipo de informação ele deve conter?",
    "options": [
      { "id": "a", "text": "Listar todas as dependências do projeto e como instalá-las, funcionando como um `package.json`." },
      { "id": "b", "text": "Fornecer diretrizes claras para potenciais contribuidores. Deve incluir como configurar o ambiente de desenvolvimento, padrões de código, o processo de submissão de pull requests (ex: branch naming, testes necessários), como relatar bugs, e um link para o código de conduta." },
      { "id": "c", "text": "Apresentar os mantenedores do projeto e seus contatos diretos para suporte técnico." },
      { "id": "d", "text": "Detalhar a arquitetura técnica completa do projeto e o roadmap de futuras versões." }
    ],
    "correctAnswerId": "b",
    "explanation": "Um bom arquivo `CONTRIBUTING.md` reduz a barreira de entrada para novos contribuidores, tornando o processo de colaboração mais eficiente, agradável e alinhado com as expectativas do projeto."
  },
  {
    "id": 81,
    "text": "Em GitHub Flavored Markdown (GFM), como você criaria um cabeçalho de segundo nível e como você faria para criar um link para uma seção específica (com um ID de cabeçalho) dentro do mesmo documento?",
    "options": [
      { "id": "a", "text": "Cabeçalho: `## Texto do Cabeçalho`. Link: `[Texto do Link](#texto-do-cabeçalho)` (IDs são gerados automaticamente a partir do texto do cabeçalho)." },
      { "id": "b", "text": "Cabeçalho: Usando `<h2>Texto do Cabeçalho</h2>`. Link: Usando `<a href=\"#custom-id\">Texto do Link</a>` e definindo o ID no h2." },
      { "id": "c", "text": "Cabeçalho: `-- Texto do Cabeçalho --`. Link: Não é possível linkar para seções em GFM." },
      { "id": "d", "text": "Cabeçalho: `**Texto do Cabeçalho**`. Link: `[Texto do Link](section:Texto do Cabeçalho)`." }
    ],
    "correctAnswerId": "a",
    "explanation": "Em Markdown, `##` seguido de um espaço e o texto cria um cabeçalho de nível 2. Para links internos, o GitHub gera automaticamente IDs para cabeçalhos (geralmente em minúsculas, com espaços substituídos por hífens). Você pode linkar para eles usando `[texto](#id-do-cabeçalho)`."
  },
  {
    "id": 82,
    "text": "Qual a sintaxe correta para criar uma lista de tarefas com um item concluído, outro pendente e um terceiro item que é um link clicável em GitHub Flavored Markdown?",
    "options": [
      { "id": "a", "text": "*- [DONE] Tarefa Concluída\n- [TODO] Tarefa Pendente\n- [LINK] [Visite o GitHub](https://github.com)*" },
      { "id": "b", "text": "*- [x] Tarefa Concluída\n- [ ] Tarefa Pendente\n- [ ] [Visite o GitHub](https://github.com)* (Este último renderiza como uma tarefa pendente com um link)" },
      { "id": "c", "text": "*<task status=\"done\">Tarefa Concluída</task>\n<task status=\"pending\">Tarefa Pendente</task>\n<task status=\"pending\"><a href=\"https://github.com\">Visite o GitHub</a></task>*" },
      { "id": "d", "text": "*1. [X] Tarefa Concluída\n2. [ ] Tarefa Pendente\n3. [] http://github.com*" }
    ],
    "correctAnswerId": "b",
    "explanation": "A sintaxe `- [x]` denota um item de tarefa concluído, e `- [ ]` denota um item pendente. Você pode incluir links Markdown normalmente dentro do texto da tarefa, como em `- [ ] [Documentação](link) para revisar`."
  },
  {
    "id": 83,
    "text": "Para um desenvolvedor que precisa gerenciar notificações, responder a comentários urgentes em Pull Requests e fazer pequenas revisões de código (como aprovar um PR que já passou nos testes) enquanto não está em seu computador principal, qual produto GitHub é mais adequado e por quê?",
    "options": [
      { "id": "a", "text": "GitHub Enterprise Server instalado em um laptop, que não é ideal para mobilidade." },
      { "id": "b", "text": "GitHub Mobile. Ele é projetado para permitir que os usuários gerenciem notificações, triem issues, revisem e mesclem pull requests, e colaborem em trânsito de forma otimizada para dispositivos móveis." },
      { "id": "c", "text": "GitHub CLI em um servidor remoto acessado por SSH, o que é menos conveniente para tarefas visuais." },
      { "id": "d", "text": "GitHub Codespaces iniciado em um tablet, que pode ser mais do que o necessário para tarefas rápidas de gerenciamento." }
    ],
    "correctAnswerId": "b",
    "explanation": "GitHub Mobile é projetado para permitir que os usuários gerenciem notificações, triem issues, revisem e mesclem pull requests, e colaborem em trânsito, oferecendo uma interface otimizada para essas tarefas em smartphones e tablets."
  },
  {
    "id": 84,
    "text": "Quando você executa `git clone https://github.com/usuario/repo.git`, o que é criado em sua máquina local, e qual o estado do seu 'working directory' (diretório de trabalho) após o clone?",
    "options": [
      { "id": "a", "text": "Um link simbólico para o repositório no GitHub; o working directory fica vazio." },
      { "id": "b", "text": "Apenas o branch `main` do repositório remoto; o working directory contém os arquivos desse branch." },
      { "id": "c", "text": "Uma cópia completa do repositório remoto, incluindo todos os arquivos, o histórico de commits de todos os branches, e uma configuração de 'remote' chamada 'origin'. Por padrão, o working directory é populado com os arquivos do branch padrão do repositório (geralmente `main` ou `master`)." },
      { "id": "d", "text": "Um novo repositório vazio com o 'remote' 'origin' já configurado; o working directory está vazio." }
    ],
    "correctAnswerId": "c",
    "explanation": "`git clone` baixa uma cópia integral do repositório. Por padrão, ele faz o checkout do branch padrão (ex: `main`), então seu diretório de trabalho conterá os arquivos daquele branch."
  },
  {
    "id": 85,
    "text": "Dar 'star' em um repositório no GitHub serve principalmente para quê, e como isso difere de 'watching' um repositório?",
    "options": [
      { "id": "a", "text": "Receber notificações detalhadas de cada commit e issue no repositório, o que é função do 'Watch'." },
      { "id": "b", "text": "Baixar automaticamente uma cópia do código para sua máquina e mantê-la sincronizada." },
      { "id": "c", "text": "Aumentar sua cota de uso de GitHub Actions para aquele repositório." },
      { "id": "d", "text": "Marcar o repositório como favorito ou interessante, facilitando encontrá-lo mais tarde em sua lista de 'estrelados'. 'Watching' é para configurar o recebimento de notificações sobre atividades no repositório." }
    ],
    "correctAnswerId": "d",
    "explanation": "Dar 'star' é uma forma de 'bookmarking' social no GitHub, ajudando a organizar projetos de interesse e a dar visibilidade a eles. 'Watch' controla as notificações que você recebe."
  },
  {
    "id": 86,
    "text": "Ao escrever uma mensagem de commit ou uma descrição de Pull Request, o uso de palavras-chave como `fixes #123`, `closes #123`, ou `resolves #123` tem qual efeito quando o commit/PR é mesclado no branch padrão do repositório?",
    "options": [
      { "id": "a", "text": "Atribui automaticamente a issue #123 ao autor do commit/PR." },
      { "id": "b", "text": "Adiciona automaticamente a label 'fixed' ou 'resolved' à issue #123." },
      { "id": "c", "text": "Fecha automaticamente a issue #123 e cria um link entre o commit/PR e a issue." },
      { "id": "d", "text": "Envia uma notificação especial para todos os 'watchers' da issue #123, informando sobre a resolução." }
    ],
    "correctAnswerId": "c",
    "explanation": "Essas palavras-chave (closing keywords) criam um link entre o commit/PR e a issue, e o GitHub as utiliza para fechar automaticamente as issues referenciadas quando o trabalho é incorporado ao branch padrão."
  },
  {
    "id": 87,
    "text": "Um desenvolvedor abriu um Pull Request, mas marcou-o como 'Draft'. Qual é a principal implicação desse status para o processo de revisão e para os checks de CI/CD?",
    "options": [
      { "id": "a", "text": "O PR não pode receber comentários nem ser visualizado por ninguém além do autor até ser marcado como 'Ready for review'." },
      { "id": "b", "text": "O PR será automaticamente mesclado após 24 horas se não houver objeções, mesmo como draft." },
      { "id": "c", "text": "O PR está visível e pode ser discutido, mas não notificará automaticamente os revisores designados (CODEOWNERS) nem acionará workflows de CI/CD que são configurados para rodar apenas em PRs 'ready for review' ou que explicitamente excluem drafts. Indica que é um trabalho em progresso." },
      { "id": "d", "text": "O PR só pode ser visualizado pelo autor e pelos administradores do repositório, e os checks de CI são executados com prioridade baixa." }
    ],
    "correctAnswerId": "c",
    "explanation": "O status 'Draft' é usado para indicar que um PR ainda está em desenvolvimento. Ele permite feedback, mas adia notificações formais e a execução de certos checks até que o autor o considere pronto para revisão completa."
  },
  {
    "id": 88,
    "text": "Durante a revisão de um Pull Request, um revisor nota um pequeno erro de digitação em uma linha de código. Qual recurso permite que ele proponha a correção diretamente no 'diff' para que o autor do PR possa aplicá-la com um clique, e qual a vantagem sobre apenas comentar?",
    "options": [
      { "id": "a", "text": "Adicionar um comentário geral solicitando a correção, o que exige que o autor interprete e aplique manualmente." },
      { "id": "b", "text": "Usar a funcionalidade de 'Suggested Changes' (Sugestões de Alterações). Isso permite ao revisor editar a(s) linha(s) no diff e propor a mudança como um patch. O autor pode então aceitar e commitar a sugestão com um clique, o que é mais rápido e menos propenso a erros." },
      { "id": "c", "text": "Editar o arquivo diretamente no branch do autor do PR, o que pode ser invasivo se não for coordenado." },
      { "id": "d", "text": "Rejeitar o PR com a opção 'Request changes' e descrever o erro de digitação." }
    ],
    "correctAnswerId": "b",
    "explanation": "As 'Suggested Changes' permitem que os revisores façam edições diretas no diff do PR, que podem ser facilmente aceitas e commitadas pelo autor, agilizando pequenas correções e mantendo o processo de revisão dentro do GitHub."
  },
  {
    "id": 89,
    "text": "Os mantenedores de um projeto querem informar a comunidade sobre o lançamento de uma nova versão major, destacando as principais funcionalidades, mudanças de quebra (breaking changes) e agradecendo aos contribuidores. Qual categoria de GitHub Discussions seria mais apropriada para este tipo de comunicação oficial?",
    "options": [
      { "id": "a", "text": "Q&A (Perguntas e Respostas), para que os usuários possam perguntar sobre a nova versão." },
      { "id": "b", "text": "Ideas (Ideias), para discutir futuras melhorias após o lançamento." },
      { "id": "c", "text": "Announcements (Anúncios). Esta categoria é ideal para comunicações importantes e unilaterais dos mantenedores para a comunidade, como notícias de lançamento, atualizações significativas ou mudanças no projeto." },
      { "id": "d", "text": "Show and Tell (Mostre e Conte), para que os usuários mostrem como estão usando a nova versão." }
    ],
    "correctAnswerId": "c",
    "explanation": "A categoria 'Announcements' em GitHub Discussions é ideal para comunicações importantes dos mantenedores para a comunidade, como notícias de lançamento, atualizações significativas ou mudanças no projeto."
  },
  {
    "id": 90,
    "text": "Um projeto tem uma discussão em GitHub Discussions que contém um guia essencial e detalhado para novos contribuidores sobre como configurar o ambiente de desenvolvimento. Como os mantenedores podem garantir que esta discussão seja facilmente encontrada por todos que visitam a seção de Discussions do repositório?",
    "options": [
      { "id": "a", "text": "Convertendo a discussão em uma issue e atribuindo-a a todos os novos membros." },
      { "id": "b", "text": "Fixando (pinning) a discussão. Isso a mantém no topo da lista de discussões do repositório, dando-lhe maior visibilidade." },
      { "id": "c", "text": "Respondendo à discussão diariamente com um 'bump' para mantê-la no topo da ordenação por atividade." },
      { "id": "d", "text": "Bloqueando a discussão para evitar novos comentários e mantê-la como referência estática." }
    ],
    "correctAnswerId": "b",
    "explanation": "Fixar uma discussão a mantém no topo da lista de discussões do repositório, tornando-a mais visível e acessível para informações importantes ou frequentemente referenciadas."
  },
  {
    "id": 91,
    "text": "Qual é o principal caso de uso para GitHub Gists em contraste com a criação de um repositório completo, e qual funcionalidade de controle de versão eles possuem?",
    "options": [
      { "id": "a", "text": "Gerenciar projetos complexos com múltiplos colaboradores, branches e issues, o que é papel de repositórios." },
      { "id": "b", "text": "Compartilhar rapidamente pequenos trechos de código, notas, scripts ou arquivos únicos. Cada Gist é um repositório Git, então eles são versionados (histórico de revisões) e podem ser clonados, forkados e comentados." },
      { "id": "c", "text": "Hospedar documentação de API interativa com múltiplos endpoints e exemplos." },
      { "id": "d", "text": "Integrar com sistemas de CI/CD para automação de build e deploy de snippets." }
    ],
    "correctAnswerId": "b",
    "explanation": "Gists são ideais para compartilhar snippets de forma ágil. Cada Gist é tecnicamente um repositório Git, o que significa que ele tem histórico de revisões, pode ser clonado, forkado, etc., mas com uma interface simplificada para esse propósito."
  },
  {
    "id": 92,
    "text": "Uma organização quer criar um site de portfólio simples para mostrar seus projetos open source, usando HTML, CSS e JavaScript, e quer que o site seja atualizado automaticamente sempre que o branch `main` do repositório do site for atualizado. Onde eles podem hospedar este site gratuitamente, diretamente de um repositório GitHub?",
    "options": [
      { "id": "a", "text": "Através da Wiki do repositório da organização, que não é ideal para sites customizados." },
      { "id": "b", "text": "Usando GitHub Pages. Ele pode ser configurado para construir e implantar automaticamente a partir de um branch específico (como `main` ou `gh-pages`) usando GitHub Actions (implícito ou customizado)." },
      { "id": "c", "text": "Em um GitHub Codespace configurado como servidor web, o que não é para hospedagem permanente." },
      { "id": "d", "text": "Armazenando os arquivos HTML como GitHub Gists e linkando-os." }
    ],
    "correctAnswerId": "b",
    "explanation": "GitHub Pages é um serviço de hospedagem estática que permite publicar sites diretamente de um repositório GitHub. Integrações com GitHub Actions podem automatizar o build e deploy a partir de pushes para branches específicos."
  },
  {
    "id": 93,
    "text": "Um desenvolvedor está construindo um workflow de GitHub Actions para testes de integração e precisa de uma action que configure o ambiente Node.js para uma versão específica. Onde ele pode procurar por actions reutilizáveis e verificadas pela comunidade ou pelo GitHub, e como ele as referencia em seu workflow?",
    "options": [
      { "id": "a", "text": "Ele deve criar todas as actions do zero para garantir segurança e personalização." },
      { "id": "b", "text": "Apenas em fóruns de discussão como Stack Overflow ou blogs de desenvolvedores." },
      { "id": "c", "text": "No GitHub Marketplace e diretamente em repositórios públicos no GitHub (ex: `actions/setup-node@v3`). Ele as referencia no arquivo YAML do workflow usando a sintaxe `uses: owner/repo@version`." },
      { "id": "d", "text": "No site oficial da Node.js Foundation, que fornece os binários, mas não Actions." }
    ],
    "correctAnswerId": "c",
    "explanation": "O GitHub Marketplace é o local principal para encontrar actions reutilizáveis. Muitas actions oficiais e populares também são hospedadas em repositórios públicos (como os da organização `actions`) e são referenciadas pela sua localização e versão no workflow."
  },
  {
    "id": 94,
    "text": "No contexto de GitHub Codespaces, qual é a função primordial de um arquivo `devcontainer.json`, e como ele pode incluir a instalação de extensões específicas do VS Code?",
    "options": [
      { "id": "a", "text": "Especificar a configuração do ambiente de desenvolvimento. Ele pode listar IDs de extensões do VS Code na propriedade `extensions` para que sejam automaticamente instaladas quando o Codespace é criado." },
      { "id": "b", "text": "Definir as variáveis de ambiente globais para todos os Codespaces do usuário, independentemente do projeto." },
      { "id": "c", "text": "Armazenar o histórico de todos os commits feitos dentro do Codespace para recuperação." },
      { "id": "d", "text": "Gerenciar os custos e limites de uso dos Codespaces para uma organização, atuando como um arquivo de billing." }
    ],
    "correctAnswerId": "a",
    "explanation": "O `devcontainer.json` permite que os projetos definam um ambiente de desenvolvimento consistente, incluindo a imagem base do contêiner, ferramentas, e também pode especificar quais extensões do VS Code devem ser instaladas automaticamente, garantindo que todos os colaboradores tenham o mesmo setup de editor."
  },
  {
    "id": 95,
    "text": "Para indicar claramente quem é o responsável por trabalhar em uma determinada Issue ou Pull Request e para permitir que os membros da equipe filtrem itens pelos quais são responsáveis, qual ação deve ser tomada no GitHub?",
    "options": [
      { "id": "a", "text": "Criar uma nova label com o nome do usuário e aplicá-la ao item, o que é apenas visual." },
      { "id": "b", "text": "Editar o título do item para incluir '[RESPONSÁVEL: @username]', o que não é uma prática padrão." },
      { "id": "c", "text": "Adicionar um comentário mencionando o nome do usuário e pedindo para ele assumir, o que é informal." },
      { "id": "d", "text": "Atribuir o item ao(s) usuário(s) relevante(s) usando a seção 'Assignees' (Responsáveis) na interface ou o comando `/assign @username` nos comentários. Isso vincula formalmente o usuário ao item." }
    ],
    "correctAnswerId": "d",
    "explanation": "A funcionalidade de 'Assignees' é a forma oficial e rastreável de designar responsabilidade por Issues e Pull Requests no GitHub, permitindo filtragem e clareza sobre quem está encarregado de quê."
  },
  {
    "id": 96,
    "text": "Uma equipe de desenvolvimento quer garantir que Pull Requests que modificam arquivos na pasta `/src/auth/` ou `/src/payment/` sejam sempre revisados pela equipe de segurança (`@octo-org/security-team`) e pelo líder técnico (`@lead-dev`). Qual arquivo de configuração do repositório deve ser usado para automatizar essa atribuição de revisores, e como múltiplas entidades podem ser especificadas?",
    "options": [
      { "id": "a", "text": "As configurações de 'Branch protection rules', que podem exigir revisões, mas não por arquivos específicos." },
      { "id": "b", "text": "O arquivo `CODEOWNERS`. Ele permite definir padrões de arquivo e os respectivos proprietários. Para múltiplos proprietários, você pode listar vários usuários ou equipes na mesma linha, separados por espaços. Ex: `/src/auth/ @octo-org/security-team @lead-dev`." },
      { "id": "c", "text": "Um `PULL_REQUEST_TEMPLATE.md` com instruções para adicionar manualmente os revisores." },
      { "id": "d", "text": "Um workflow de GitHub Actions que comenta no PR mencionando a equipe e o líder." }
    ],
    "correctAnswerId": "b",
    "explanation": "O arquivo `CODEOWNERS` permite definir padrões de arquivo e os respectivos proprietários (usuários ou equipes) que serão automaticamente solicitados para revisão. Múltiplos proprietários podem ser listados para um mesmo padrão."
  },
  {
    "id": 97,
    "text": "Qual opção de visibilidade de repositório no GitHub permite que apenas membros da organização (em uma conta GitHub Enterprise) e colaboradores explicitamente adicionados vejam e contribuam para o repositório, mas não o público em geral nem usuários GitHub fora da organização?",
    "options": [
      { "id": "a", "text": "Privado (Private), que restringe a visibilidade apenas a colaboradores explicitamente convidados, mesmo dentro de uma organização." },
      { "id": "b", "text": "Interno (Internal). Esta opção, disponível para contas Enterprise, torna o repositório visível e acessível para todos os membros da organização, sem ser público para a internet. Colaboradores externos ainda podem ser adicionados." },
      { "id": "c", "text": "Público (Public), que é visível para qualquer pessoa na internet." },
      { "id": "d", "text": "Restrito (Restricted), que é um nível de permissão, não uma configuração de visibilidade de repositório." }
    ],
    "correctAnswerId": "b",
    "explanation": "A visibilidade 'Internal' (disponível para contas Enterprise) torna o repositório visível e acessível para todos os membros da organização, sem ser público para a internet. Repositórios privados são visíveis apenas para colaboradores convidados, mesmo dentro da mesma organização, a menos que a equipe inteira seja adicionada."
  },
  {
    "id": 98,
    "text": "De que forma o programa GitHub Sponsors beneficia diretamente os mantenedores de projetos de código aberto, e qual o papel do GitHub nesse processo?",
    "options": [
      { "id": "a", "text": "Garantindo que seus projetos sejam destacados na página inicial do GitHub e recebam consultoria técnica." },
      { "id": "b", "text": "Concedendo-lhes automaticamente permissões de administrador em qualquer repositório que utilizem e oferecendo descontos em publicidade." },
      { "id": "c", "text": "Fornecendo uma plataforma para que eles recebam apoio financeiro (doações recorrentes ou pontuais) da comunidade e de empresas. O GitHub facilita essa transação, muitas vezes cobrindo taxas de processamento e oferecendo ferramentas para os mantenedores se comunicarem com seus patrocinadores." },
      { "id": "d", "text": "Oferecendo um salário fixo para todos os mantenedores de projetos com mais de 1000 estrelas." }
    ],
    "correctAnswerId": "c",
    "explanation": "GitHub Sponsors é uma ferramenta para que desenvolvedores e organizações open source possam receber financiamento para sustentar seu trabalho. O GitHub atua como intermediário, facilitando as doações e a interação entre patrocinadores e patrocinados."
  },
  {
    "id": 99,
    "text": "Um desenvolvedor precisa de uma ferramenta para análise estática de código que se integre diretamente ao seu fluxo de Pull Requests no GitHub, fornecendo feedback sobre qualidade e potenciais bugs antes do merge. Onde ele deveria procurar por tais ferramentas e como elas geralmente se integram?",
    "options": [
      { "id": "a", "text": "Nas configurações de perfil do GitHub, onde pode habilitar análises globais." },
      { "id": "b", "text": "No GitHub Marketplace. Muitas ferramentas de análise estática (como CodeQL, SonarCloud, Snyk) estão disponíveis como GitHub Apps ou Actions, que podem ser configuradas para rodar automaticamente em PRs e reportar resultados como checks ou comentários." },
      { "id": "c", "text": "Em blogs de desenvolvimento populares, esperando encontrar scripts para download e configuração manual." },
      { "id": "d", "text": "Na documentação oficial da linguagem de programação que ele está usando, que pode listar linters, mas não integrações diretas com GitHub PRs." }
    ],
    "correctAnswerId": "b",
    "explanation": "O GitHub Marketplace é o local centralizado para encontrar aplicativos e ações que se integram ao GitHub. Ferramentas de análise estática geralmente se integram como GitHub Actions ou GitHub Apps que rodam em eventos de PR, postando resultados como status checks."
  },
  {
    "id": 100,
    "text": "Ao comparar 'InnerSource' com 'open source', qual afirmação é mais precisa sobre as motivações e o escopo de cada um?",
    "options": [
      { "id": "a", "text": "InnerSource é um pré-requisito para que um projeto se torne open source, servindo como um estágio de teste interno." },
      { "id": "b", "text": "Open source refere-se ao desenvolvimento colaborativo de software com código-fonte publicamente acessível, motivado por benefícios comunitários e inovação aberta. InnerSource é a aplicação dessas mesmas metodologias e cultura colaborativa dentro de uma organização para seus projetos internos, motivado por eficiência interna, reuso de código e quebra de silos." },
      { "id": "c", "text": "Projetos InnerSource são obrigatoriamente hospedados no GitHub Enterprise Server, enquanto open source pode usar github.com ou outras plataformas." },
      { "id": "d", "text": "A principal diferença é que InnerSource não permite o uso de branches, apenas o trunk-based development, enquanto open source é flexível." }
    ],
    "correctAnswerId": "b",
    "explanation": "InnerSource busca trazer os benefícios da colaboração, transparência e reuso do modelo open source para o desenvolvimento de software dentro de uma empresa, mantendo o código restrito à organização. As motivações são internas (eficiência, qualidade) enquanto no open source são mais amplas e comunitárias."
  },
  {
    "id": 101,
    "text": "Quando você faz um 'fork' de um repositório público, quais elementos NÃO são copiados para o seu fork por padrão, e por que isso acontece?",
    "options": [
      { "id": "a", "text": "O histórico de commits e os branches, pois o fork começa como um repositório vazio." },
      { "id": "b", "text": "Issues, Pull Requests abertos no original, Wiki, configurações do repositório (como secrets, webhooks, branch protection rules) e permissões de colaboradores. Estes são específicos da instância do repositório original e não são propriedade do forkador." },
      { "id": "c", "text": "Os arquivos e a estrutura de diretórios do branch padrão." },
      { "id": "d", "text": "O arquivo README.md e o arquivo LICENSE, pois são considerados opcionais." }
    ],
    "correctAnswerId": "b",
    "explanation": "Um fork copia o código (arquivos, branches, histórico de commits). Elementos como issues, PRs existentes no original, a Wiki, configurações específicas do repositório (secrets, webhooks, permissões de colaboradores, regras de proteção de branch, etc.) e GitHub Actions workflows (exceto se explicitamente incluídos) não são copiados para o fork, pois são contextuais ao repositório original."
  },
  {
    "id": 102,
    "text": "Para exibir um conteúdo personalizado e rico em Markdown diretamente na sua página de perfil do GitHub, como uma introdução, lista de habilidades e projetos em destaque, o que você precisa fazer?",
    "options": [
      { "id": "a", "text": "Habilitar uma 'Feature Preview' específica para perfis avançados nas configurações da conta." },
      { "id": "b", "text": "Criar um repositório público com o mesmo nome que o seu nome de usuário GitHub (ex: `seu-usuario/seu-usuario`) e adicionar um arquivo `README.md` a ele. O conteúdo deste README será automaticamente renderizado em sua página de perfil." },
      { "id": "c", "text": "Publicar um Gist chamado `PROFILE.md` e marcá-lo como público." },
      { "id": "d", "text": "Editar as configurações de 'Bio' no seu perfil para incluir a sintaxe Markdown completa." }
    ],
    "correctAnswerId": "b",
    "explanation": "Este é o mecanismo para criar um 'Profile README'. O conteúdo do `README.md` nesse repositório especial (com o mesmo nome do seu usuário) será renderizado na sua página de perfil, permitindo uma apresentação rica e personalizada."
  },
  {
    "id": 103,
    "text": "Qual é o impacto da configuração do arquivo `CODEOWNERS` em um Pull Request que modifica arquivos listados nele, e como isso se relaciona com as regras de proteção de branch?",
    "options": [
      { "id": "a", "text": "Altera o autor do Pull Request para um dos code owners se o autor original não tiver permissão." },
      { "id": "b", "text": "Impede que qualquer pessoa, exceto os code owners, comente no Pull Request para manter o foco." },
      { "id": "c", "text": "Automaticamente solicita a revisão dos code owners especificados para os caminhos de arquivo modificados. Se as regras de proteção de branch estiverem configuradas para 'Require review from Code Owners', o PR pode ser bloqueado até que pelo menos um code owner aprove." },
      { "id": "d", "text": "Mescla automaticamente o Pull Request se todos os code owners já o aprovaram anteriormente em outros PRs." }
    ],
    "correctAnswerId": "c",
    "explanation": "`CODEOWNERS` garante que as partes relevantes do código sejam revisadas pelas pessoas ou equipes designadas como proprietárias. Quando combinado com regras de proteção de branch, isso pode se tornar um requisito para o merge."
  },
  {
    "id": 104,
    "text": "Um gerente de produto quer destacar as 3 issues mais críticas para a próxima sprint na página principal de Issues do repositório, para que toda a equipe tenha visibilidade imediata delas. Qual funcionalidade ele deve usar?",
    "options": [
      { "id": "a", "text": "Atribuir as issues a si mesmo e pedir para a equipe filtrar por ele." },
      { "id": "b", "text": "Fixar (pin) as issues. O GitHub permite fixar até três issues (ou pull requests) no topo da lista de issues de um repositório, dando-lhes maior visibilidade." },
      { "id": "c", "text": "Adicionar a label 'CRITICAL' e instruir a equipe a ordenar por essa label." },
      { "id": "d", "text": "Criar um Milestone chamado 'Top Issues' e adicionar apenas essas três issues." }
    ],
    "correctAnswerId": "b",
    "explanation": "O GitHub permite fixar até três issues (e também pull requests) no topo da lista de issues de um repositório, dando-lhes maior visibilidade para todos os colaboradores."
  },
  {
    "id": 105,
    "text": "Qual das seguintes atividades NÃO é uma capacidade central do GitHub Desktop, e qual seria uma alternativa para essa atividade?",
    "options": [
      { "id": "a", "text": "Fazer commit de alterações e sincronizá-las com um repositório remoto no GitHub.com ou GitHub Enterprise." },
      { "id": "b", "text": "Criar, fazer checkout e mesclar branches localmente, e visualizar o histórico de commits." },
      { "id": "c", "text": "Executar e depurar workflows do GitHub Actions em seu ambiente local. Para simular workflows localmente, ferramentas como `act` podem ser usadas, mas não são parte do GitHub Desktop." },
      { "id": "d", "text": "Resolver conflitos de merge simples através de uma interface visual." }
    ],
    "correctAnswerId": "c",
    "explanation": "GitHub Desktop é uma interface gráfica para Git e para interagir com repositórios GitHub. Ele não executa workflows do GitHub Actions localmente; esses workflows rodam em executores (runners) na nuvem do GitHub ou auto-hospedados. Ferramentas de terceiros como `act` podem simular a execução local de workflows."
  }
]

    